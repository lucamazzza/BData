Index: src/main/java/ch/mazluc/data/Tuple.java
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Tuple.java b/src/main/java/ch/mazluc/data/Tuple.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/data/Tuple.java	
+++ /dev/null	
@@ -1,766 +0,0 @@
-package ch.mazluc.data;
-
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-import java.util.Random;
-import java.util.function.Predicate;
-import java.util.stream.IntStream;
-
-import static java.lang.System.arraycopy;
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/**
- * <p>
- * This class represents a tuple of values.
- * A tuple is a sequence of values that can be
- * accessed by index, it is weakly typed and
- * is also iterable.
- * Implements the {@link Data} interface
- *
- * <p>
- * Usage:
- *
- * <pre>
- * {@code
- * Tuple tuple = new Tuple(); // create an empty tuple
- * tuple.push(1); // add a value
- * tuple.push(2); // add another value
- * tuple.push(3); // add another value
- * for (int i = 0; i < tuple.length(); i++) { // iterate on the tuple
- *     System.out.println(tuple.getValue(i));
- * }
- * }
- * </pre>
- *
- * <p>
- * See Repo for more: <a href="https://github.com/lucamazzza/BData">GitHub</a>
- *
- * @author Luca Mazza
- * @version 1.0
- */
-public class Tuple implements Data {
-
-    /**
-     * Message when an object is not a tuple
-     */
-    private static final String NOT_A_TUPLE = "Object is not a tuple";
-
-    /**
-     * Random generator.
-     * Used to generate random values throughout the class.
-     */
-    private static final Random random = new Random();
-
-    /**
-     * The values of the tuple.
-     * Values are stored in an array of Objects, as they can be of any type.
-     *
-     * <p>
-     * The values of the tuple can be accessed by index.
-     */
-    private Object[] values;
-
-    /**
-     * Creates a new instance of a Tuple.
-     *
-     * <p>
-     * Instantiates an empty array of values, with a length of 0.
-     */
-    public Tuple() {
-        this.values = new Object[0];
-    }
-
-    /**
-     * Creates a new instance of tuple.Tuple
-     * Defines the values of the tuple
-     *
-     * @param values the values of the tuple
-     * 
-     */
-    public Tuple(Object... values) {
-        if (values.length == 0) {
-            this.values = new Object[0];
-            return;
-        }
-        this.values = new Object[values.length];
-        arraycopy(values, 0, this.values, 0, values.length);
-        this.clearNulls();
-    }
-
-    /**
-     * Determines if the given object is an instance of Tuple.
-     *
-     * @param obj the object to be checked
-     * @return  true if the object is an instance of Tuple, false otherwise
-     */
-    static boolean isTuple(Object obj) {
-        return obj.getClass() == Tuple.class;
-    }
-
-    /**
-     * Returns the length of the tuple
-     *
-     * @return the length of the tuple
-     * 
-     */
-    @Override
-    public int length() {
-        return this.values.length;
-    }
-
-    /**
-     * Returns if the tuple is empty
-     *
-     * @return if the tuple is empty
-     * 
-     */
-    @Override
-    public boolean isEmpty(){
-        return this.values.length == 0;
-    }
-
-    /**
-     * Returns if the tuple is equal to another
-     *
-     * @param obj the tuple to compare
-     * @return if the tuple is equal to another
-     * 
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (obj != null && !isTuple(obj)) {
-            return false;
-        }
-        Tuple tuple = (Tuple) obj;
-        assert tuple != null;
-        if(this.values.length != tuple.values.length){
-            return false;
-        }
-        for (int i = 0; i < this.values.length; i++) {
-            if (this.values[i] != tuple.values[i]){
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Determines whether the given value is contained within the collection.
-     *
-     * @param value the value to check for containment
-     * @return true if the value is contained, false otherwise
-     * 
-     */
-    @Override
-    public <T> boolean contains(T value) {
-        return this.indexOf(value) != -1;
-    }
-
-    /**
-     * Returns if the tuple contains a value of the specified type
-     *
-     * @param type the type of the value
-     * @return if the tuple contains a value of the specified type
-     * 
-     */
-    public boolean containsType(Class<?> type) {
-        for (Object value : this.values) {
-            if (value == null) {
-                return false;
-            }
-            if (value.getClass() == type) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Replaces the values of the tuple
-     *
-     * @param values the new values of the tuple
-     * 
-     */
-    public void setValues(Object... values){
-        if (values.length == 0) {
-            this.values = new Object[0];
-            return;
-        }
-        this.values = values;
-        this.clearNulls();
-    }
-
-    /**
-     * Appends a value of T type to the tuple
-     *
-     * @param <T> value the value to append
-     * 
-     */
-    @Override
-    public <T> void push(T value) {
-        if (value == null) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length + 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length);
-        newValues[this.values.length] = value;
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Inserts a new value at the specified index
-     *
-     * @param index index to insert the value into
-     * @param value value to insert
-     * 
-     */
-    public <T> void insert(int index, T value) throws IndexOutOfBoundsException {
-        if (value == null) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length + 1];
-        arraycopy(this.values, 0, newValues, 0, index);
-        newValues[index] = value;
-        arraycopy(this.values, index, newValues, index + 1, this.values.length - index);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Replaces the value at the specified index
-     *
-     * @param index the index of the value
-     * @param value the new value
-     * 
-     */
-    public <T> void replace(int index, T value) throws IndexOutOfBoundsException {
-        if (value == null) {
-            return;
-        }
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length " + this.values.length);
-        }
-        this.values[index] = value;
-        this.clearNulls();
-    }
-
-    /**
-     * Swaps the elements at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     * 
-     */
-    @Override
-    public void swap(int index1, int index2) throws IndexOutOfBoundsException {
-        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index out of bounds for length " + this.values.length);
-        }
-        Object temp = this.values[index1];
-        this.values[index1] = this.values[index2];
-        this.values[index2] = temp;
-    }
-
-    /**
-     * Returns the value at the specified index of the tuple
-     * Value is already typed, but be careful, put your values
-     * in a rightful type variable
-     *
-     * @param index the index of the value
-     * @return the value at the specified index
-     */
-    @SuppressWarnings("unchecked")
-    public <T> T getValue(int index) throws IndexOutOfBoundsException {
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length " + this.values.length);
-        }
-        return (T) this.values[index];
-    }
-
-    /**
-     * Returns a new tuple with only the values of the specified type
-     *
-     * @param type the type of the values (to pass as `Class.class`, for example `Integer.class`)
-     * @return a new tuple with only the values of the specified type
-     */
-    public Tuple getValuesOfType(Class<?> type) {
-        Tuple tuple = new Tuple();
-        if (!containsType(type)) {
-            return tuple;
-        }
-        Tuple copy = new Tuple(this.values); // Create a copy of the original tuple
-        for (int i = 0; i < copy.length(); i++) {
-            if (copy.getValue(i) == null) {
-                copy.remove(i);
-            }
-        }
-        for (Object value : copy) {
-            if (value.getClass() == type) {
-                tuple.push(value);
-            }
-        }
-        return tuple;
-    }
-
-    /**
-     * Returns the index of a specified value
-     *
-     * @param value the value to search
-     * @return the index of the value
-     */
-    public <T> int indexOf(T value) {
-        for (int i = 0; i < this.values.length; i++) {
-            if (value instanceof String && this.values[i].equals(value.toString())) {
-                return i;
-            }
-            if (value instanceof Tuple && this.values[i].equals(value)) {
-                return i;
-            }
-            if (this.values[i] != null && this.values[i].equals(value)) {
-                return i;
-            }
-            if (this.values[i] == value) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    /**
-     * Removes the last value of the tuple
-     */
-    @Override
-    public void pop() {
-        if (this.values.length == 0) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Removes the element at the specified index from the array of values.
-     *
-     * @param index the index of the element to be removed
-     * 
-     */
-    public void remove(int index) throws IndexOutOfBoundsException {
-        if (this.values.length == 0) {
-            return;
-        }
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException();
-        }
-        Object[] newValues = new Object[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, index);
-        if (this.values.length - 1 - index >= 0)
-            arraycopy(this.values, index + 1, newValues, index, this.values.length - 1 - index);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Clears the tuple, making it of length 0
-     *
-     * 
-     */
-    @Override
-    public void clear() {
-        this.values = new Object[0];
-    }
-
-    /**
-     * Clears T null values from the array.
-     */
-    private void clearNulls() {
-        if (this.values.length == 0) {
-            return;
-        }
-        for (int i = 0; i < this.values.length; i++) {
-            if (this.values[i] == null) {
-                this.remove(i);
-            }
-        }
-    }
-
-    /**
-     * Returns the string representation of the tuple
-     *
-     * @return the string representation of the tuple
-     * 
-     */
-    @Override
-    public String toString() {
-        if (this.values.length == 0) {
-            return "[]";
-        }
-        return Arrays.toString(this.values);
-    }
-
-    /**
-     * Returns the hash code of the tuple
-     *
-     * @return the hash code of the tuple
-     * 
-     */
-    @Override
-    public int hashCode() {
-        if (this.values.length == 0) {
-            return 0;
-        }
-        return Arrays.hashCode(this.values);
-    }
-
-    /**
-     * Reverses the tuple
-     *
-     * 
-     */
-    public void reverse() {
-        if (this.values.length == 0 || this.values.length == 1) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length];
-        for (int i = 0; i < this.values.length; i++) {
-            newValues[i] = this.values[this.values.length - i - 1];
-        }
-        this.setValues(newValues);
-    }
-
-    /**
-     * Slices the tuple from a defined start to a defined end
-     *
-     * @param start the first index
-     * @param end   the last index
-     * 
-     */
-    @Override
-    public void slice(int start, int end) {
-        if (end > this.values.length) {
-            end = this.values.length;
-        }
-        if (start < 0) {
-            start = 0;
-        }
-        Object[] newValues = new Object[end - start];
-        arraycopy(this.values, start, newValues, 0, newValues.length);
-        this.setValues(newValues);
-    }
-
-    /**
-     * Splits the tuple at the specified index
-     * The new tuple has the same length as the old one
-     *
-     * @param index the index to split
-     * @param data the new tuple
-     * 
-     */
-    public void split(int index, Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (index > this.values.length) {
-            index = this.values.length;
-        }
-        if (index < 0) {
-            index = 0;
-        }
-        Tuple tmp = (Tuple) data;
-        Object[] newValues = new Object[index];
-        Object[] newValues2 = new Object[this.values.length - index];
-        arraycopy(this.values, index, newValues2, 0, this.values.length - index);
-        tmp.setValues(newValues2);
-        arraycopy(this.values, 0, newValues, 0, index);
-        this.setValues(newValues);
-    }
-
-    /**
-     * Joins two tuples into one
-     *
-     * @param datas the tuples to join
-     * 
-     */
-    @Override
-    public void join(Object... datas) {
-        for (Object data : datas) {
-            if (!isTuple(data)) {
-                continue;
-            }
-            Tuple tmp = (Tuple) data;
-            for (int i = 0; i < tmp.length(); i++) {
-                this.push(tmp.getValue(i));
-            }
-        }
-    }
-
-    /**
-     * Fills the array with the specified value.
-     *
-     * @param value the value to fill the array with
-     */
-    public <T> void fill(T value, int amount) {
-        if (amount < 0) { amount = 0; }
-        if (amount == 0 || value == null) { return; }
-        for (int i = 0; i < amount; i++) {
-            this.push(value);
-        }
-    }
-
-    /**
-     * Fills the array with random values.
-     *
-     * @param amount the amount of random values to generate
-     */
-    public void fillRandom(int amount) {
-        if (amount < 0 || amount > this.values.length) {
-            amount = 0;
-        }
-        if (amount == 0) {
-            return;
-        }
-        for (int i = 0; i < amount; i++) {
-            this.values[i] = random.nextInt(100);
-        }
-    }
-
-    /**
-     * Fills the values array with random integers between 0 and 99 (inclusive).
-     */
-    public void fillRandom(int min, int max, int amount) {
-        if (amount < 0 || amount > this.values.length) {
-            amount = 0;
-        }
-        if (amount == 0) {
-            return;
-        }
-        if (min > max) {
-            int tmp = min;
-            min = max;
-            max = tmp;
-        }
-        for (int i = 0; i < amount; i++) {
-
-            this.values[i] = random.nextInt(max - min + 1) + min;
-        }
-    }
-
-    /**
-     * Determines if this tuple is a subset of the given tuple.
-     *
-     * @param data the tuple to check against
-     * @return true if this tuple is a subset of the given tuple, false otherwise
-     */
-    @Override
-    public boolean isSubsetOf(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (this.length() > ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < this.length(); i++) {
-            if (!tmp.contains(this.getValue(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Determines if this tuple is a superset of the given tuple.
-     *
-     * @param data the tuple to check against
-     * @return true if this tuple is a superset of the given tuple, false otherwise
-     */
-    @Override
-    public boolean isSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (this.length() < ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        return tmp.isSubsetOf(this);
-    }
-
-    /**
-     * Determines if this set is a strict superset of the given tuple.
-     * A strict superset means that this set contains all the values
-     * of the given tuple in the same order
-     *
-     * @param data the tuple to compare against
-     * @return true if this set is a strict superset of the given tuple, false otherwise
-     */
-    public boolean isStrictSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (this.length() < ((Tuple) data).length()) {
-            return false;
-        }
-        int consecutive = 0;
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < tmp.length(); i++) {
-            if (this.contains(tmp.getValue(i))) {
-                consecutive++;
-            } else {
-                consecutive = 0;
-            }
-        }
-        return consecutive == tmp.length();
-    }
-
-    /**
-     * Determines if this set is a strict subset of the given tuple.
-     * A strict subset means that this set contains all the values
-     * of the given tuple in the same order
-     *
-     * @param data the tuple to compare against
-     * @return true if this set is a strict subset of the given tuple, false otherwise
-     */
-    public boolean isStrictSubsetOf(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (this.length() > ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        int consecutive = 0;
-        for (int i = 0; i < this.length(); i++) {
-            if (tmp.contains(this.getValue(i))){
-                consecutive++;
-            } else {
-                consecutive = 0;
-            }
-        }
-        return consecutive == this.length();
-    }
-
-    /**
-     * Checks if the current tuple.Tuple is disjoint with the given tuple.Tuple.
-     *
-     * @param data the tuple.Tuple to check for disjointness
-     * @return true if the Tuples are disjoint, false otherwise
-     */
-    @Override
-    public boolean isDisjoint(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        if (data.equals(this)) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < tmp.length(); i++) {
-            if (this.contains(tmp.getValue(i))){
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns the symmetric difference between this tuple and the given tuple
-     * The symmetric difference is the set of values that are in either tuple
-     * but not in both
-     *
-     * @param data the tuple
-     * @return the symmetric difference
-     */
-    public Object symmetricDifference(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        Tuple tuple = (Tuple) data;
-        Tuple result = new Tuple();
-        for (int i = 0; i < this.length(); i++) {
-            if (!tuple.contains(this.getValue(i))) {
-                result.push(this.getValue(i));
-            }
-        }
-        for (int i = 0; i < tuple.length(); i++) {
-            if (!this.contains(tuple.getValue(i))) {
-                result.push(tuple.getValue(i));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Subtracts the given tuple from this tuple
-     *
-     * @param data the tuple
-     * @return the result
-     */
-    @Override
-    public Object subtract(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(NOT_A_TUPLE); }
-        Tuple tmp = (Tuple) data;
-        Tuple result = new Tuple();
-        for (int i = 0; i < this.length(); i++) {
-            if (!tmp.contains(this.getValue(i))){
-                result.push(this.getValue(i));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Filters the elements of the tuple.Tuple based on the given predicate.
-     *
-     * @param predicate the predicate used to filter the elements of the tuple.Tuple
-     * @return the filtered tuple.Tuple
-     */
-    @Override
-    public Object filter(Predicate<Object> predicate){
-        Tuple result = new Tuple();
-        IntStream.range(
-                0,
-                this.length()
-        )
-        .filter(
-            i -> predicate.test(this.getValue(i))
-        ).mapToObj(
-                this::getValue
-        ).forEachOrdered(result::push);
-
-        return result;
-    }
-
-    /**
-     * Returns an iterator over elements of type {@code T}.
-     *
-     * @return an Iterator.
-     */
-    @Override
-    public Iterator<Object> iterator() {
-        return new Iterator<>() {
-            private int currentIndex = 0;
-
-            @Override
-            public boolean hasNext() {
-                return currentIndex < length() && values[currentIndex] != null;
-            }
-
-            @Override
-            public Object next() {
-                if (!hasNext()) { throw new NoSuchElementException(); }
-                return values[currentIndex++];
-            }
-        };
-    }
-
-}
\ No newline at end of file
Index: src/test/java/ch/mazluc/data/TupleTest.java
===================================================================
diff --git a/src/test/java/ch/mazluc/data/TupleTest.java b/src/test/java/ch/mazluc/data/TupleTest.java
deleted file mode 100644
--- a/src/test/java/ch/mazluc/data/TupleTest.java	
+++ /dev/null	
@@ -1,409 +0,0 @@
-package ch.mazluc.data;
-import org.junit.jupiter.api.Test;
-
-import java.math.BigInteger;
-
-import static org.junit.jupiter.api.Assertions.*;
-class TupleTest {
-
-    @Test
-    void length() {
-        Tuple tuple = new Tuple();
-        assertEquals(0, tuple.length());
-        tuple.push(1);
-        assertEquals(1, tuple.length());
-        tuple.push(2);
-        assertEquals(2, tuple.length());
-        tuple.push(3);
-        assertEquals(3, tuple.length());
-    }
-
-    @Test
-    void isEmpty() {
-        Tuple tuple = new Tuple();
-        assertTrue(tuple.isEmpty());
-        tuple.push(1);
-        assertFalse(tuple.isEmpty());
-        tuple.pop();
-        assertTrue(tuple.isEmpty());
-    }
-
-    @Test
-    void testEquals() {
-        Data tuple = new Tuple();
-        Data tuple2 = new Tuple();
-        tuple.push(1);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(1);
-        assertEquals(tuple, tuple2);
-        tuple.push(2);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(2);
-        assertEquals(tuple, tuple2);
-        tuple.push(3);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(3);
-        assertEquals(tuple, tuple2);
-        tuple.push(4);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(4);
-        assertEquals(tuple, tuple2);
-    }
-
-    @Test
-    void contains() {
-        Data tuple = new Tuple(1);
-        tuple.push(1);
-        assertTrue(tuple.contains(1));
-        assertFalse(tuple.contains(2));
-    }
-
-    @Test
-    void containsType() {
-        Tuple tuple = new Tuple(1);
-        tuple.push(1);
-        assertTrue(tuple.containsType(Integer.class));
-        assertFalse(tuple.containsType(String.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push(null);
-        assertFalse(tuple.containsType(Object.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push("test");
-        assertTrue(tuple.containsType(String.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push(true);
-        assertTrue(tuple.containsType(Boolean.class));
-    }
-
-    @Test
-    void setValues() {
-        Tuple tuple = new Tuple();
-        tuple.setValues(1, 2, 3, 4, 5);
-        assertEquals(5, tuple.length());
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertEquals(4, (int)tuple.getValue(3));
-        assertEquals(5, (int)tuple.getValue(4));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-        assertNotEquals(8, (int)tuple.getValue(3));
-        assertNotEquals(1, (int)tuple.getValue(4));
-    }
-
-    @Test
-    void push() {
-        Tuple tuple = new Tuple();
-        tuple.push(1);
-        tuple.push(2);
-        tuple.push(3);
-        assertEquals(3, tuple.length());
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void insert() {
-        Tuple tuple = new Tuple(0);
-        tuple.insert(0, 2);
-        tuple.insert(2, 3);
-        assertEquals(3, tuple.length());
-        assertEquals(2, (int)tuple.getValue(0));
-        assertEquals(0, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(0, (int)tuple.getValue(0));
-        assertNotEquals(3, (int)tuple.getValue(1));
-        assertNotEquals(2, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void replace() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        tuple.replace(0, 1);
-        tuple.replace(1, 2);
-        tuple.replace(2, 3);
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void swap() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        tuple.swap(0, 1);
-        tuple.swap(1, 2);
-        tuple.swap(2, 3);
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void getValue() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        assertEquals(0, (int)tuple.getValue(0));
-        assertEquals(1, (int)tuple.getValue(1));
-        assertEquals(2, (int)tuple.getValue(2));
-        assertEquals(3, (int)tuple.getValue(3));
-        assertEquals(4, (int)tuple.getValue(4));
-        assertEquals(5, (int)tuple.getValue(5));
-        assertEquals(6, (int)tuple.getValue(6));
-        assertEquals(7, (int)tuple.getValue(7));
-        assertEquals(8, (int)tuple.getValue(8));
-        assertEquals(9, (int)tuple.getValue(9));
-        assertEquals("2", tuple.getValue(10));
-        assertEquals(false, tuple.getValue(11));
-    }
-
-    @Test
-    void getValuesOfType() {
-        BigInteger s = new BigInteger("12345678901234567890123456789012345678901234567890");
-        Tuple tuple = new Tuple(1, 2, 3, 4.0f, 5.5, 5.65, "Ciao", false, null, s);
-        assertEquals(tuple.getValuesOfType(Integer.class), new Tuple(1, 2, 3));
-        assertTrue(tuple.getValuesOfType(Float.class).contains(4.0f));
-        assertTrue(tuple.getValuesOfType(Double.class).contains(5.5));
-        assertEquals(tuple.getValuesOfType(String.class), new Tuple("Ciao"));
-        assertTrue(tuple.getValuesOfType(BigInteger.class).contains(s));
-    }
-
-    @Test
-    void indexOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        assertEquals(0, tuple.indexOf(0));
-        assertEquals(1, tuple.indexOf(1));
-        assertEquals(2, tuple.indexOf(2));
-        assertEquals(3, tuple.indexOf(3));
-        assertEquals(4, tuple.indexOf(4));
-        assertEquals(5, tuple.indexOf(5));
-        assertEquals(6, tuple.indexOf(6));
-        assertEquals(7, tuple.indexOf(7));
-        assertEquals(8, tuple.indexOf(8));
-        assertEquals(9, tuple.indexOf(9));
-        assertEquals(10, tuple.indexOf("2"));
-        assertEquals(11, tuple.indexOf(false));
-    }
-
-    @Test
-    void pop() {
-        Data tupleEmpty = new Tuple();
-        tupleEmpty.pop();
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        tuple.pop();
-        assertEquals(11, tuple.length());
-        tuple.pop();
-        assertEquals(10, tuple.length());
-        tuple.pop();
-        assertEquals(9, tuple.length());
-        tuple.pop();
-        assertEquals(8, tuple.length());
-        tuple.pop();
-        assertEquals(7, tuple.length());
-        tuple.pop();
-        assertEquals(6, tuple.length());
-    }
-
-    @Test
-    void remove() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        tuple.remove(0);
-        assertEquals("[1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false]", tuple.toString());
-        tuple.remove(tuple.length() - 1);
-        assertEquals("[1, 2, 3, 4, 5, 6, 7, 8, 9, 2]", tuple.toString());
-        assertFalse(tuple.contains(false));
-        assertThrows(IndexOutOfBoundsException.class, () -> tuple.remove(-1));
-        tuple.clear();
-        tuple.remove(0);
-    }
-
-    @Test
-    void clear() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.clear();
-        assertEquals(0, tuple.length());
-        tuple.clear();
-        assertEquals(0, tuple.length());
-    }
-
-    @Test
-    void testToString() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        assertEquals("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false]", tuple.toString());
-        tuple.clear();
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void reverse() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.reverse();
-        assertEquals( "[false, 2, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",tuple.toString());
-        tuple.clear();
-        tuple.reverse();
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void slice() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.slice(1, 4);
-        assertEquals( "[1, 2, 3]",tuple.toString());
-        tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.slice(7, tuple.length());
-        assertEquals( "[7, 8, 9, 2, false]", tuple.toString());
-        tuple.clear();
-        tuple.slice(0, 1);
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void split() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        Tuple tuple2 = new Tuple();
-        tuple.split(7, tuple2);
-        assertEquals( "[0, 1, 2, 3, 4, 5, 6]", tuple.toString());
-        assertEquals( "[7, 8, 9, 2, false]", tuple2.toString());
-        tuple.clear();
-        tuple.split(1, tuple2);
-        assertEquals("[]", tuple.toString());
-        assertEquals("[]", tuple2.toString());
-    }
-
-    @Test
-    void join() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6);
-        Data tuple2 = new Tuple(7, 8, 9, 2, null, false);
-        Data tuple3 = new Tuple(null, null, "ciao");
-        Data tuple4 = new Tuple();
-        tuple.join(tuple2, tuple3, tuple4);
-        assertEquals( "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false, ciao]", tuple.toString());
-        tuple3.clear();
-        tuple.join(tuple2, tuple3, tuple4);
-        assertEquals("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false, ciao, 7, 8, 9, 2, false]", tuple.toString());
-    }
-
-    @Test
-    void fill() {
-        Tuple tuple = new Tuple();
-        tuple.fill(1, 10);
-        assertEquals( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-        tuple.fill(1, 10);
-        assertEquals( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-        tuple.fill(1, 0);
-        assertEquals("[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-    }
-
-    @Test
-    void isSubsetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2");
-        Tuple tuple2 = new Tuple(0, 9, 2, 3, 7, 5, 6, 4, 8, 1, "2", null, null, null, false);
-        assertTrue(tuple.isSubsetOf(tuple2));
-        tuple.push("1");
-        assertFalse(tuple.isSubsetOf(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isSubsetOf(tuple2));
-    }
-
-    @Test
-    void isSupersetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, null, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 3, false, null, null, null, 2);
-        assertTrue(tuple.isSupersetOf(tuple2));
-        tuple2.pop();
-        tuple2.push("1");
-        assertFalse(tuple.isSupersetOf(tuple2));
-        tuple2.clear();
-        assertTrue(tuple.isSupersetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isSupersetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isSupersetOf("0"));
-        assertDoesNotThrow(() -> tuple.isSupersetOf(new Tuple()));
-    }
-
-    @Test
-    void isStrictSupersetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false);
-        assertTrue(tuple.isStrictSupersetOf(tuple2));
-        tuple2.pop();
-        tuple2.push("1");
-        assertFalse(tuple.isStrictSupersetOf(tuple2));
-        tuple2.clear();
-        assertTrue(tuple.isStrictSupersetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isStrictSupersetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isStrictSupersetOf("0"));
-        assertDoesNotThrow(() -> tuple.isStrictSupersetOf(new Tuple()));
-    }
-
-    @Test
-    void isStrictSubsetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, false);
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, "cuai");
-        assertTrue(tuple.isStrictSubsetOf(tuple2));
-        tuple2.pop();
-        tuple.push("1");
-        assertFalse(tuple.isStrictSubsetOf(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isStrictSubsetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isStrictSubsetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isStrictSubsetOf("0"));
-        assertDoesNotThrow(() -> tuple.isStrictSubsetOf(new Tuple()));
-    }
-
-    @Test
-    void isDisjoint() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, null, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, null, false, null, null);
-        assertFalse(tuple.isDisjoint(tuple2));
-        tuple2.clear();
-        tuple2.push("-1");
-        assertTrue(tuple.isDisjoint(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isDisjoint(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isDisjoint(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isDisjoint("0"));
-        assertDoesNotThrow(() -> tuple.isDisjoint(new Tuple()));
-    }
-
-    @Test
-    void symmetricDifference() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[4, 5, cuai]", tuple.symmetricDifference(tuple2).toString());
-        tuple2.push("-1");
-        assertEquals("[4, 5, cuai, -1]", tuple.symmetricDifference(tuple2).toString());
-        assertThrows(NullPointerException.class, () -> tuple.symmetricDifference(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.symmetricDifference("0"));
-        assertDoesNotThrow(() -> tuple.symmetricDifference(new Tuple()));
-    }
-
-    @Test
-    void subtract() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[4, 5, cuai]", tuple.subtract(tuple2).toString());
-        tuple2.push("-1");
-        assertEquals("[4, 5, cuai]", tuple.subtract(tuple2).toString());
-        assertThrows(NullPointerException.class, () -> tuple.subtract(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.subtract("0"));
-        assertDoesNotThrow(() -> tuple.subtract(new Tuple()));
-    }
-
-    @Test
-    void filter() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[0, 1, 2, 3, 4, 5]", tuple.filter(o -> o instanceof Integer).toString());
-        tuple2.push(-1);
-        assertEquals("[-1]", tuple2.filter(o -> o instanceof Integer && (int) o < 0).toString());
-    }
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/data/Table.java
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Table.java b/src/main/java/ch/mazluc/data/Table.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/data/Table.java	
+++ /dev/null	
@@ -1,473 +0,0 @@
-package ch.mazluc.data;
-
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-import java.util.function.Predicate;
-
-import static java.lang.System.arraycopy;
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/**
- * <p>
- * Represents a table.
- * A table is a collection of tuples.
- * Allows to iterate through the tuples and to run
- * some different operations on the tuples.
- * It is an implementation of the {@link Data} interface.
- *
- * <p>
- * Usage:
- * <pre>
- * {@code
- * Data table = new Table();
- * table.push(new Tuple(1, 2));
- * table.push(new Tuple(3, 4));
- * table.delete(0);
- * table.push(new Tuple(5, 6));
- * table.push(new Tuple(7, 8));
- * table.slice(1, 2);
- * }
- * </pre>
- *
- * <p>
- * See Repo for more: <a href="https://github.com/lucamazzza/BData">GitHub</a>
- *
- * @author Luca Mazza
- * @version 1.0
- */
-public class Table implements Data{
-
-    /**
-     * Message when an index is out of bounds
-     */
-    private static final String OUT_OF_BOUNDS = "Index out of bounds for length ";
-
-    /**
-     * Message when an object is not a table
-     */
-    private static final String NOT_A_TABLE = "Object is not a table";
-
-    /**
-     * The values of the table
-     */
-    private Tuple[] values;
-
-    /**
-     * Creates a new, empty table
-     */
-    public Table(){
-        this.values = new Tuple[0];
-    }
-
-    /**
-     * Creates a new table with the specified values
-     * @param values the values
-     */
-    public Table(Tuple... values){
-        this.values = values;
-    }
-
-    private static boolean isTable(Object o) {
-        return Table.class == o.getClass();
-    }
-
-    /**
-     * Retrieves the length of the object.
-     *
-     * @return the length of the object.
-     */
-    @Override
-    public int length() {
-        return this.values.length;
-    }
-
-    /**
-     * Checks if the object is empty.
-     *
-     * @return true if the object is empty, false otherwise
-     */
-    @Override
-    public boolean isEmpty() {
-        return this.values.length == 0;
-    }
-
-    @Override
-    public boolean equals(Object o) throws IllegalArgumentException {
-        if (o == this)
-            return true;
-        if (o == null)
-            return false;
-        if (isTable(o)) {
-            Table table = (Table) o;
-            if (this.length() != table.length()) {
-                return false;
-            }
-            for (int i = 0; i < this.length(); i++) {
-                if (!this.values[i].equals(table.values[i])) {
-                    return false;
-                }
-            }
-            return true;
-        } else throw new IllegalArgumentException(NOT_A_TABLE);
-    }
-
-    @Override
-    public int hashCode() {
-        int hashCode = 0;
-        for (Tuple value : this.values) {
-            hashCode += value.hashCode();
-        }
-        return hashCode;
-    }
-
-    /**
-     * Determines whether the function contains the specified value.
-     *
-     * @param value the value to be checked if it is contained in the function
-     * @return true if the value is contained in the function, otherwise false
-     */
-    @Override
-    public <T> boolean contains(T value) {
-        if (this.isEmpty()) { return false; }
-        if (Tuple.isTuple(value)) {
-            for (Tuple tuple : this.values) {
-                if (tuple.equals(value)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-        for (Tuple tuple : this.values) {
-            if (tuple.contains(value)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Sets the values of the collection.
-     *
-     * @param values an array of values to be set
-     */
-    @SafeVarargs
-    public final <T> void setValues(T... values) {
-        this.clear();
-        for (T value : values) {
-            if (value == null) {
-                continue;
-            }
-            this.push(value);
-        }
-    }
-
-    /**
-     * Pushes a value onto the collection.
-     *
-     * @param value the value to be pushed onto the stack
-     */
-    @Override
-    public <T> void push(T value) throws IllegalArgumentException {
-        if (this.values.length == 0) {
-            this.values = new Tuple[1];
-            this.values[0] = (value instanceof Tuple t) ? t : new Tuple(value);
-            return;
-        }
-        Tuple[] tmp = new Tuple[this.length() + 1];
-        arraycopy(this.values, 0, tmp, 0, this.length());
-        tmp[tmp.length - 1] = (value instanceof Tuple t) ? t : new Tuple(value);
-        this.values = tmp;
-    }
-
-    /**
-     * Inserts a new value at the specified index
-     *
-     * @param row index to insert the value into
-     * @param col index to insert the value into
-     * @param value value to insert
-     */
-    public <T> void insert(int row, int col, T value) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
-        }
-        this.values[row].insert(col, value);
-    }
-
-    /**
-     * Replaces the element at the specified index with the given value.
-     *
-     * @param row the index of the element to be replaced
-     * @param col the index of the element to be replaced
-     * @param value the value to replace the element with
-     */
-    public <T> void replace(int row, int col, T value) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
-        }
-        this.values[row].replace(col, value);
-    }
-
-    /**
-     * Swaps the rows at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     */
-    @Override
-    public void swap(int index1, int index2) throws IndexOutOfBoundsException {
-        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {
-            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
-        }
-        Tuple temp = this.values[index1];
-        this.values[index1] = this.values[index2];
-        this.values[index2] = temp;
-    }
-
-    /**
-     * Retrieves the value at the specified index.
-     *
-     * @param row the index of the value
-     * @param col the index of the value
-     * @return the value at the specified index
-     */
-    public <T> T getValue(int row, int col) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
-        }
-        return this.values[row].getValue(col);
-    }
-
-    /**
-     * Returns the index of a specified value
-     *
-     * @param value the value to search
-     * @return the index of the value
-     */
-    public <T> int[] indexOf(T value) {
-        int[] coordinates = new int[2];
-        for (int i = 0; i < this.values.length; i++) {
-            for (int j = 0; j < this.values[i].length(); j++) {
-                if (this.values[i].getValue(j).equals(value)) {
-                    coordinates[0] = i;
-                    coordinates[1] = j;
-                    return coordinates;
-                }
-            }
-        }
-        return coordinates;
-    }
-
-    /**
-     * Removes the value at the last index
-     */
-    @Override
-    public void pop() {
-        if (this.values.length == 0) {
-            return;
-        }
-        Tuple[] newValues = new Tuple[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);
-        this.values = newValues;
-    }
-
-    /**
-     * Removes the element at the specified index
-     *
-     * @param row the index of the element to be removed
-     * @param col the index of the element to be removed
-     */
-    public void remove(int row, int col) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
-        }
-        this.values[row].remove(col);
-    }
-
-    /**
-     * Clears the table
-     */
-    @Override
-    public void clear() {
-        this.values = new Tuple[0];
-    }
-
-    /**
-     * Slice the table from a defined row to a defined row
-     *
-     * @param start the index to start
-     * @param end   the index to end
-     */
-    @Override
-    public void slice(int start, int end) {
-        if (end > this.values.length) {
-            end = this.values.length;
-        }
-        if (start < 0) {
-            start = 0;
-        }
-        Tuple[] newValues = new Tuple[end - start];
-        arraycopy(this.values, start, newValues, 0, newValues.length);
-        this.values = newValues;
-    }
-
-    /**
-     * Joins two or more tables
-     *
-     * @param datas the tables to join
-     */
-    @Override
-    public void join(Object... datas) {
-        for (Object data : datas) {
-            if (!isTable(data)) { continue; }
-            for (Tuple value : ((Table) data).values) {
-                this.push(value);
-            }
-        }
-    }
-
-    /**
-     * Returns true if this table is a subset of the given table
-     *
-     * @param data the table
-     * @return true if this table is a subset of the given table
-     */
-    @Override
-    public boolean isSubsetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
-        Table table = (Table) data;
-        if (this.length() > table.length()) {
-            return false;
-        }
-        int count = 0;
-        for (int i = 0; i < table.length(); i++) {
-            if (this.contains(table.values[i])) {
-                count++;
-            }
-        }
-        return count == this.length();
-
-    }
-
-    /**
-     * Returns true if this table is a superset of the given table
-     *
-     * @param data the table
-     * @return true if this table is a superset of the given table
-     */
-    @Override
-    public boolean isSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
-        Table table = (Table) data;
-        return table.isSubsetOf(this);
-    }
-
-
-    /**
-     * Subtracts the given table from this table
-     *
-     * @param data the table
-     * @return the difference
-     */
-    @Override
-    public Object subtract(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
-        Table tmp = new Table();
-        Table table = (Table) data;
-        for (Tuple value : this.values) {
-            if (!table.contains(value)) {
-                tmp.push(value);
-            }
-        }
-        return tmp;
-    }
-
-    /**
-     * Filters the table using `Predicates`
-     * Returns the Tuples containing the values that match the predicate
-     *
-     * @param predicate the predicate
-     * @return the filtered table
-     */
-    @Override
-    public Object filter(Predicate<Object> predicate) {
-        Tuple result = new Tuple();
-        for (Tuple value : this.values) {
-            if(!((Tuple)value.filter(predicate)).isEmpty()) {
-                result.join(value.filter(predicate));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Returns true if this table is disjoint from the given table
-     * Disjunction is the set of values that are in either table
-     * but not in both
-     *
-     * @param data the table
-     * @return true if this table is disjoint from the given table
-     */
-    @Override
-    public boolean isDisjoint(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
-        Table table = (Table) data;
-        for (Tuple value : table.values) {
-            for (int i = 0; i < value.length(); i++) {
-                if (this.contains(value.getValue(i))) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder out = new StringBuilder();
-        for (Object value : this.values) out.append(value).append("\n");
-        return out.toString();
-    }
-
-    /**
-     * Returns an iterator over elements of type {@code T}.
-     *
-     * @return an Iterator.
-     */
-    @Override
-    public Iterator<Object> iterator() {
-        return new Iterator<>() {
-            private int currentIndex = 0;
-
-            @Override
-            public boolean hasNext() {
-                return currentIndex < length() && values[currentIndex] != null;
-            }
-
-            @Override
-            public Tuple next() throws NoSuchElementException {
-                if (!hasNext()) { throw new NoSuchElementException(); }
-                return values[currentIndex++];
-            }
-        };
-    }
-}
Index: src/test/java/ch/mazluc/data/TableTest.java
===================================================================
diff --git a/src/test/java/ch/mazluc/data/TableTest.java b/src/test/java/ch/mazluc/data/TableTest.java
deleted file mode 100644
--- a/src/test/java/ch/mazluc/data/TableTest.java	
+++ /dev/null	
@@ -1,352 +0,0 @@
-package ch.mazluc.data;
-
-import ch.mazluc.data.Table;
-import ch.mazluc.data.Tuple;
-import org.junit.jupiter.api.Test;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-class TableTest {
-
-    @Test
-    void length() {
-        Table table = new Table();
-        assertEquals(0, table.length());
-        table.push(new Tuple(0, 1, 2));
-        assertEquals(1, table.length());
-        table.push(new Tuple(3, 4, 5));
-        assertEquals(2, table.length());
-    }
-
-    @Test
-    void isEmpty() {
-        Table table = new Table();
-        assertTrue(table.isEmpty());
-        table.push(new Tuple(0, 1, 2));
-        table.push(new Tuple(3, 4, 5));
-        assertFalse(table.isEmpty());
-    }
-
-    @Test
-    void contains() {
-        Table table = new Table();
-        table.push(new Tuple(0, 1, 2));
-        table.push(new Tuple(3, 4, 5));
-        assertTrue(table.contains(0));
-        assertFalse(table.contains(6));
-        assertTrue(table.contains(2));
-        table.clear();
-        assertFalse(table.contains(0));
-    }
-
-    @Test
-    void setValues() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1), 1, 2, new Tuple(3, 4, 5, 6), 4);
-        assertEquals(5, table.length());
-        assertEquals(0, (int)table.getValue(0, 0));
-        assertEquals(1, (int)table.getValue(1,0));
-        assertEquals(2, (int)table.getValue(2,0));
-        assertEquals(6, (int)table.getValue(3,3));
-        assertEquals(4, (int)table.getValue(4,0));
-    }
-
-    @Test
-    void push() {
-        Table table = new Table();
-        table.push(1);
-        table.push(new Tuple(2, 3));
-        table.push(3);
-        assertFalse(table.isEmpty());
-        assertTrue(table.contains(1));
-        assertTrue(table.contains(2));
-        assertTrue(table.contains(3));
-        assertEquals(3, table.length());
-        assertEquals(1, (int)table.getValue(0,0));
-        assertEquals(2, (int)table.getValue(1,0));
-        assertEquals(3, (int)table.getValue(2,0));
-    }
-
-    @Test
-    void insert() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(6.5e13, 1, false),
-                new Tuple(1, 'e', 3),
-                new Tuple(3, 4.4, 5)
-        );
-        table.insert(0, 0, 6);
-        table.insert(1, 1, 7);
-        table.insert(2, 2, 8);
-        assertTrue(table.contains(6));
-        assertTrue(table.contains(7));
-        assertTrue(table.contains(8));
-        assertEquals(3, table.length());
-        assertEquals(6, (int)table.getValue(0,0));
-        assertEquals(7, (int)table.getValue(1,1));
-        assertEquals(8, (int)table.getValue(2,2));
-    }
-
-    @Test
-    void replace() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, "1", false),
-                new Tuple(1, 3.3, 3),
-                new Tuple(3, 4f, 5)
-        );
-        table.replace(0, 0, 6);
-        table.replace(1, 1, 7);
-        table.replace(2, 2, 8);
-        assertTrue(table.contains(6));
-        assertTrue(table.contains(7));
-        assertTrue(table.contains(8));
-        assertEquals(3, table.length());
-        assertEquals(6, (int)table.getValue(0,0));
-        assertEquals(7, (int)table.getValue(1,1));
-        assertEquals(8, (int)table.getValue(2,2));
-    }
-
-    @Test
-    void swap() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.swap(0, 1);
-        table.swap(1, 2);
-        assertEquals(3, (int)table.getValue(0,0));
-        assertEquals(0, (int)table.getValue(2,0));
-        assertFalse((boolean) table.getValue(1, 4));
-        assertNotEquals(2, (int)table.getValue(0,0));
-        assertNotEquals(1, (int)table.getValue(1,0));
-    }
-
-    @Test
-    void getValue() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(3, (int)table.getValue(1,0));
-        assertEquals(7, (int)table.getValue(2,0));
-        assertEquals(2, (int)table.getValue(0,2));
-        assertEquals("2", table.getValue(2,3));
-    }
-
-    @Test
-    void indexOf() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertArrayEquals(new int[]{0, 0}, table.indexOf(0));
-        assertArrayEquals(new int[]{0, 1}, table.indexOf(1));
-        assertArrayEquals(new int[]{0, 2}, table.indexOf(2));
-        assertArrayEquals(new int[]{1, 0}, table.indexOf(3));
-        assertArrayEquals(new int[]{1, 1}, table.indexOf(4));
-        assertArrayEquals(new int[]{1, 2}, table.indexOf(5));
-        assertArrayEquals(new int[]{1, 3}, table.indexOf(6));
-        assertArrayEquals(new int[]{2, 0}, table.indexOf(7));
-        assertArrayEquals(new int[]{2, 1}, table.indexOf(8));
-        assertArrayEquals(new int[]{2, 2}, table.indexOf(9));
-        assertArrayEquals(new int[]{2, 3}, table.indexOf("2"));
-        assertArrayEquals(new int[]{2, 4}, table.indexOf(false));
-    }
-
-    @Test
-    void pop() {
-        Table table = new Table(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.pop();
-        assertEquals(2, table.length());
-        table.pop();
-        assertEquals(1, table.length());
-        table.pop();
-        assertEquals(0, table.length());
-        table.pop();
-        assertEquals(0, table.length());
-    }
-
-    @Test
-    void remove() {
-        Table table = new Table(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.remove(0, 0);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(0));
-        table.remove(1, 1);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(4));
-        table.remove(2, 2);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(9));
-        table.remove(0, 0);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(0));
-    }
-
-    @Test
-    void clear() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.clear();
-        assertEquals(0, table.length());
-        assertFalse(table.contains(5));
-        assertFalse(table.contains(6));
-        assertFalse(table.contains(7));
-        assertFalse(table.contains(8));
-        assertFalse(table.contains(9));
-    }
-
-    @Test
-    void slice() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.slice(0, 2);
-        assertEquals(2, table.length());
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(6, (int)table.getValue(1,3));
-        table.slice(1, 2);
-        assertEquals(1 , table.length());
-        assertEquals(4, (int)table.getValue(0, 1));
-
-    }
-
-    @Test
-    void join() {
-        Table table = new Table();
-        Table table1 = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6));
-        table1.setValues(new Tuple(7, 8, 9, "2", false), new Tuple(true, 'a'));
-        table.join(table1);
-        assertEquals(4, table.length());
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(1, (int)table.getValue(0,1));
-        assertEquals(2, (int)table.getValue(0,2));
-        assertEquals(3, (int)table.getValue(1,0));
-        assertEquals(4, (int)table.getValue(1,1));
-        assertEquals(5, (int)table.getValue(1,2));
-        assertEquals(6, (int)table.getValue(1,3));
-        assertEquals(7, (int)table.getValue(2,0));
-        assertEquals(8, (int)table.getValue(2,1));
-        assertEquals(9, (int)table.getValue(2,2));
-        assertEquals("2", table.getValue(2,3));
-        assertEquals(false, table.getValue(2,4));
-        assertEquals(true, table.getValue(3,0));
-        assertEquals('a', (char)table.getValue(3,1));
-    }
-
-    @Test
-    void isSubsetOf() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6));
-        Table table1 = new Table();
-        table1.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9, "2"));
-        assertTrue(table.isSubsetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9, "2"));
-        assertTrue(table.isSubsetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2));
-        assertFalse(table.isSubsetOf(table1));
-    }
-
-    @Test
-    void isSupersetOf() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        Table table1 = new Table();
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertTrue(table.isSupersetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true)
-        );
-        assertFalse(table.isSupersetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true),
-                new Tuple(13, 14, 15, "4", false)
-        );
-        assertFalse(table.isSupersetOf(table1));
-    }
-
-    @Test
-    void subtract() {
-        Table table = new Table();
-        Table table1 = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9));
-        table1.setValues(new Tuple(0, 1, 2));
-        Table comp = new Table(new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9));
-        Table subt = (Table) table.subtract(table1);
-        assertEquals(comp, subt);
-    }
-
-    @Test
-    void filter() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3.0, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertEquals("[2]", table.filter(t -> t instanceof String).toString());
-        assertEquals("[0, 1, 2, 4, 5, 6, 7, 8, 9]", table.filter(t -> t instanceof Integer).toString());
-        assertEquals("[3.0]", table.filter(t -> t instanceof Double).toString());
-        assertEquals("[0, 1, 2, 3.0, 4, 5, 6, 7, 8, 9]", table.filter(t -> t instanceof Number).toString());
-    }
-
-    @Test
-    void isDisjoint() {
-        Table table = new Table();
-        table.setValues(new Tuple("ciao", true), new Tuple(0.2, 4.4f));
-        Table table1 = new Table();
-        table1.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertTrue(table.isDisjoint(table1));
-        table1.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true)
-        );
-        assertFalse(table.isDisjoint(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", false)
-        );
-        assertTrue(table.isDisjoint(table1));
-    }
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/data/Data.java
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Data.java b/src/main/java/ch/mazluc/data/Data.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/data/Data.java	
+++ /dev/null	
@@ -1,154 +0,0 @@
-package ch.mazluc.data;
-
-import java.util.function.Predicate;
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-/**
- * <p>
- * Represents a data structure.
- * A data structure is a collection of values.
- * It is an extension of the {@link Iterable} interface.
- *
- * <p>
- * Usage:
- *
- * <pre>
- * {@code
- * 
- * }
- * </pre>
- *
- * <p>
- * See Repo for more: <a href="https://github.com/lucamazzza/BData">GitHub</a>
- *
- * @author Luca Mazza
- * @version 1.0
- */
-public interface Data extends Iterable<Object> {
-
-    /**
-     * Retrieves the length of the object.
-     *
-     * @return the length of the object.
-     */
-    int length();
-
-    /**
-     * Checks if the object is empty.
-     *
-     * @return true if the object is empty, false otherwise
-     */
-    boolean isEmpty();
-
-    /**
-     * Determines whether the function contains the specified value.
-     *
-     * @param value the value to be checked if it is contained in the function
-     * @return true if the value is contained in the function, otherwise false
-     * @param <T> the type
-     */
-    <T>boolean contains(T value);
-
-    /**
-     * Pushes a value onto the collection.
-     *
-     * @param value the value to be pushed onto the stack
-     * @param <T> the type
-     */
-    <T> void push(T value);
-
-    /**
-     * Swaps the elements at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     */
-    void swap(int index1, int index2) throws IndexOutOfBoundsException;
-
-    /**
-     * Removes the value at the last index
-     */
-    void pop();
-
-    /**
-     * Clears the array
-     */
-    void clear();
-
-    /**
-     * Slice the collection from a defined start to a defined end
-     *
-     * @param start the index to start
-     * @param end   the index to end
-     */
-    void slice(int start, int end);
-
-    /**
-     * Joins two or more tuples
-     *
-     * @param datas the tuples to join
-     */
-    void join(Object... datas);
-
-    /**
-     * Returns true if this tuple is a subset of the given tuple
-     *
-     * @param data the tuple
-     * @return true if this tuple is a subset of the given tuple
-     */
-    boolean isSubsetOf(Object data);
-
-    /**
-     * Returns true if this tuple is a superset of the given tuple
-     *
-     * @param data the tuple
-     * @return true if this tuple is a superset of the given tuple
-     */
-    boolean isSupersetOf(Object data);
-
-    /**
-     * Subtracts the given tuple from this tuple
-     *
-     * @param data the tuple
-     * @return the difference
-     */
-    Object subtract(Object data);
-
-    /**
-     * Filters the tuple using `Predicates`
-     *
-     * @param predicate the predicate
-     * @return the filtered tuple
-     */
-    Object filter(Predicate<Object> predicate);
-
-    /**
-     * Returns true if this tuple is disjoint from the given tuple
-     * Disjunction is the set of values that are in either tuple
-     * but not in both
-     *
-     * @param data the tuple
-     * @return true if this tuple is disjoint from the given tuple
-     */
-    boolean isDisjoint(Object data);
-}
\ No newline at end of file
diff --git a/.idea/sonarlint/issuestore/3/6/36183789120773293e7f995870d67508d5889165 b/.idea/sonarlint/issuestore/3/6/36183789120773293e7f995870d67508d5889165
deleted file mode 100644
diff --git a/.idea/sonarlint/securityhotspotstore/a/8/a84756550be34ae47d2dd29f19ed4609f6a2a974 b/.idea/sonarlint/securityhotspotstore/a/8/a84756550be34ae47d2dd29f19ed4609f6a2a974
deleted file mode 100644
diff --git a/.idea/sonarlint/issuestore/c/4/c4cdac5d06bef18a37b82eb82f6d9ed1c5c59e78 b/.idea/sonarlint/issuestore/c/4/c4cdac5d06bef18a37b82eb82f6d9ed1c5c59e78
deleted file mode 100644
diff --git a/.idea/sonarlint/securityhotspotstore/c/4/c4cdac5d06bef18a37b82eb82f6d9ed1c5c59e78 b/.idea/sonarlint/securityhotspotstore/c/4/c4cdac5d06bef18a37b82eb82f6d9ed1c5c59e78
deleted file mode 100644
diff --git a/.idea/sonarlint/securityhotspotstore/3/6/36183789120773293e7f995870d67508d5889165 b/.idea/sonarlint/securityhotspotstore/3/6/36183789120773293e7f995870d67508d5889165
deleted file mode 100644
diff --git a/.idea/sonarlint/issuestore/a/8/a84756550be34ae47d2dd29f19ed4609f6a2a974 b/.idea/sonarlint/issuestore/a/8/a84756550be34ae47d2dd29f19ed4609f6a2a974
deleted file mode 100644
