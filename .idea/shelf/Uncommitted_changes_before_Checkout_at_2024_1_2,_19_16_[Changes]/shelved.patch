Index: src/main/java/ch/mazluc/data/Tuple.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.mazluc.data;\n\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.function.Predicate;\nimport java.util.stream.IntStream;\n\nimport static java.lang.System.arraycopy;\n/*\n * MIT License\n *\n * Copyright (c) 2023 Luca Mazza\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/**\n * <h1>\n * Tuple\n * </h1>\n *\n * <p>\n * This class represents a tuple of values.\n * A tuple is a sequence of values that can be\n * accessed by index, it is weakly typed and\n * is also iterable.\n * Implements the {@link Data} interface\n *\n * <p>\n * Usage:\n *\n * <pre>\n * {@code\n * Tuple tuple = new Tuple(); // create an empty tuple\n * tuple.push(1); // add a value\n * tuple.push(2); // add another value\n * tuple.push(3); // add another value\n * for (int i = 0; i < tuple.length(); i++) { // iterate on the tuple\n *     System.out.println(tuple.getValue(i));\n * }\n * }\n * </pre>\n *\n * <p>\n * See Repo for more: <a href=\"https://github.com/lucamazzza/BData\">GitHub</a>\n *\n * @author Luca Mazza\n * @version 1.0\n */\npublic class Tuple implements Data {\n\n    /**\n     * Message when an object is not a tuple\n     */\n    private static final String OINAT = \"Object is not a tuple\";\n\n    /**\n     * Random generator.\n     * Used to generate random values throughout the class.\n     */\n    private static final Random random = new Random();\n\n    /**\n     * The values of the tuple.\n     * Values are stored in an array of Objects, as they can be of any type.\n     *\n     * <p>\n     * The values of the tuple can be accessed by index.\n     */\n    private Object[] values;\n\n    /**\n     * Creates a new instance of a Tuple.\n     *\n     * <p>\n     * Instantiates an empty array of values, with a length of 0.\n     */\n    public Tuple() {\n        this.values = new Object[0];\n    }\n\n    /**\n     * Creates a new instance of tuple.Tuple\n     * Defines the values of the tuple\n     *\n     * @param values the values of the tuple\n     * \n     */\n    public Tuple(Object... values) {\n        if (values.length == 0) {\n            this.values = new Object[0];\n            return;\n        }\n        this.values = new Object[values.length];\n        arraycopy(values, 0, this.values, 0, values.length);\n        this.clearNulls();\n    }\n\n    /**\n     * Determines if the given object is an instance of Tuple.\n     *\n     * @param obj the object to be checked\n     * @return  true if the object is an instance of Tuple, false otherwise\n     */\n    static boolean isTuple(Object obj) {\n        return obj.getClass() == Tuple.class;\n    }\n\n    /**\n     * Returns the length of the tuple\n     *\n     * @return the length of the tuple\n     * \n     */\n    @Override\n    public int length() {\n        return this.values.length;\n    }\n\n    /**\n     * Returns if the tuple is empty\n     *\n     * @return if the tuple is empty\n     * \n     */\n    @Override\n    public boolean isEmpty(){\n        return this.values.length == 0;\n    }\n\n    /**\n     * Returns if the tuple is equal to another\n     *\n     * @param obj the tuple to compare\n     * @return if the tuple is equal to another\n     * \n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj != null && !isTuple(obj)) {\n            return false;\n        }\n        Tuple tuple = (Tuple) obj;\n        assert tuple != null;\n        if(this.values.length != tuple.values.length){\n            return false;\n        }\n        for (int i = 0; i < this.values.length; i++) {\n            if (this.values[i] != tuple.values[i]){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Determines whether the given value is contained within the collection.\n     *\n     * @param value the value to check for containment\n     * @return true if the value is contained, false otherwise\n     * \n     */\n    @Override\n    public <T> boolean contains(T value) {\n        return this.indexOf(value) != -1;\n    }\n\n    /**\n     * Returns if the tuple contains a value of the specified type\n     *\n     * @param type the type of the value\n     * @return if the tuple contains a value of the specified type\n     * \n     */\n    public boolean containsType(Class<?> type) {\n        for (Object value : this.values) {\n            if (value == null) {\n                return false;\n            }\n            if (value.getClass() == type) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Replaces the values of the tuple\n     *\n     * @param values the new values of the tuple\n     * \n     */\n    public void setValues(Object... values){\n        if (values.length == 0) {\n            this.values = new Object[0];\n            return;\n        }\n        this.values = values;\n        this.clearNulls();\n    }\n\n    /**\n     * Appends a value of T type to the tuple\n     *\n     * @param <T> value the value to append\n     * \n     */\n    @Override\n    public <T> void push(T value) {\n        if (value == null) {\n            return;\n        }\n        Object[] newValues = new Object[this.values.length + 1];\n        arraycopy(this.values, 0, newValues, 0, this.values.length);\n        newValues[this.values.length] = value;\n        this.values = newValues;\n        this.clearNulls();\n    }\n\n    /**\n     * Inserts a new value at the specified index\n     *\n     * @param index index to insert the value into\n     * @param value value to insert\n     * \n     */\n    public <T> void insert(int index, T value) throws IndexOutOfBoundsException {\n        if (value == null) {\n            return;\n        }\n        Object[] newValues = new Object[this.values.length + 1];\n        arraycopy(this.values, 0, newValues, 0, index);\n        newValues[index] = value;\n        arraycopy(this.values, index, newValues, index + 1, this.values.length - index);\n        this.values = newValues;\n        this.clearNulls();\n    }\n\n    /**\n     * Replaces the value at the specified index\n     *\n     * @param index the index of the value\n     * @param value the new value\n     * \n     */\n    public <T> void replace(int index, T value) throws IndexOutOfBoundsException {\n        if (value == null) {\n            return;\n        }\n        if (index < 0 || index >= this.values.length) {\n            throw new IndexOutOfBoundsException(\"Index \" + index + \" out of bounds for length \" + this.values.length);\n        }\n        this.values[index] = value;\n        this.clearNulls();\n    }\n\n    /**\n     * Swaps the elements at the specified indices in the array.\n     *\n     * @param index1 the index of the first element to be swapped\n     * @param index2 the index of the second element to be swapped\n     * \n     */\n    @Override\n    public void swap(int index1, int index2) throws IndexOutOfBoundsException {\n        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {\n            throw new IndexOutOfBoundsException(\"Index out of bounds for length \" + this.values.length);\n        }\n        Object temp = this.values[index1];\n        this.values[index1] = this.values[index2];\n        this.values[index2] = temp;\n    }\n\n    /**\n     * Returns the value at the specified index of the tuple\n     * Value is already typed, but be careful, put your values\n     * in a rightful type variable\n     *\n     * @param index the index of the value\n     * @return the value at the specified index\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getValue(int index) throws IndexOutOfBoundsException {\n        if (index < 0 || index >= this.values.length) {\n            throw new IndexOutOfBoundsException(\"Index \" + index + \" out of bounds for length \" + this.values.length);\n        }\n        return (T) this.values[index];\n    }\n\n    /**\n     * Returns a new tuple with only the values of the specified type\n     *\n     * @param type the type of the values (to pass as `Class.class`, for example `Integer.class`)\n     * @return a new tuple with only the values of the specified type\n     */\n    public Tuple getValuesOfType(Class<?> type) {\n        Tuple tuple = new Tuple();\n        if (!containsType(type)) {\n            return tuple;\n        }\n        Tuple copy = new Tuple(this.values); // Create a copy of the original tuple\n        for (int i = 0; i < copy.length(); i++) {\n            if (copy.getValue(i) == null) {\n                copy.remove(i);\n            }\n        }\n        for (Object value : copy) {\n            if (value.getClass() == type) {\n                tuple.push(value);\n            }\n        }\n        return tuple;\n    }\n\n    /**\n     * Returns the index of a specified value\n     *\n     * @param value the value to search\n     * @return the index of the value\n     */\n    public <T> int indexOf(T value) {\n        for (int i = 0; i < this.values.length; i++) {\n            if (value instanceof String && this.values[i].equals(value.toString())) {\n                return i;\n            }\n            if (value instanceof Tuple && this.values[i].equals(value)) {\n                return i;\n            }\n            if (this.values[i] != null && this.values[i].equals(value)) {\n                return i;\n            }\n            if (this.values[i] == value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Removes the last value of the tuple\n     */\n    @Override\n    public void pop() {\n        if (this.values.length == 0) {\n            return;\n        }\n        Object[] newValues = new Object[this.values.length - 1];\n        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);\n        this.values = newValues;\n        this.clearNulls();\n    }\n\n    /**\n     * Removes the element at the specified index from the array of values.\n     *\n     * @param index the index of the element to be removed\n     * \n     */\n    public void remove(int index) throws IndexOutOfBoundsException {\n        if (this.values.length == 0) {\n            return;\n        }\n        if (index < 0 || index >= this.values.length) {\n            throw new IndexOutOfBoundsException();\n        }\n        Object[] newValues = new Object[this.values.length - 1];\n        arraycopy(this.values, 0, newValues, 0, index);\n        if (this.values.length - 1 - index >= 0)\n            arraycopy(this.values, index + 1, newValues, index, this.values.length - 1 - index);\n        this.values = newValues;\n        this.clearNulls();\n    }\n\n    /**\n     * Clears the tuple, making it of length 0\n     *\n     * \n     */\n    @Override\n    public void clear() {\n        this.values = new Object[0];\n    }\n\n    /**\n     * Clears T null values from the array.\n     */\n    private void clearNulls() {\n        if (this.values.length == 0) {\n            return;\n        }\n        for (int i = 0; i < this.values.length; i++) {\n            if (this.values[i] == null) {\n                this.remove(i);\n            }\n        }\n    }\n\n    /**\n     * Returns the string representation of the tuple\n     *\n     * @return the string representation of the tuple\n     * \n     */\n    @Override\n    public String toString() {\n        if (this.values.length == 0) {\n            return \"[]\";\n        }\n        return Arrays.toString(this.values);\n    }\n\n    /**\n     * Returns the hash code of the tuple\n     *\n     * @return the hash code of the tuple\n     * \n     */\n    @Override\n    public int hashCode() {\n        if (this.values.length == 0) {\n            return 0;\n        }\n        return Arrays.hashCode(this.values);\n    }\n\n    /**\n     * Reverses the tuple\n     *\n     * \n     */\n    public void reverse() {\n        if (this.values.length == 0 || this.values.length == 1) {\n            return;\n        }\n        Object[] newValues = new Object[this.values.length];\n        for (int i = 0; i < this.values.length; i++) {\n            newValues[i] = this.values[this.values.length - i - 1];\n        }\n        this.setValues(newValues);\n    }\n\n    /**\n     * Slices the tuple from a defined start to a defined end\n     *\n     * @param start the first index\n     * @param end   the last index\n     * \n     */\n    @Override\n    public void slice(int start, int end) {\n        if (end > this.values.length) {\n            end = this.values.length;\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        Object[] newValues = new Object[end - start];\n        arraycopy(this.values, start, newValues, 0, newValues.length);\n        this.setValues(newValues);\n    }\n\n    /**\n     * Splits the tuple at the specified index\n     * The new tuple has the same length as the old one\n     *\n     * @param index the index to split\n     * @param data the new tuple\n     * \n     */\n    public void split(int index, Object data) throws IllegalArgumentException {\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (index > this.values.length) {\n            index = this.values.length;\n        }\n        if (index < 0) {\n            index = 0;\n        }\n        Tuple tmp = (Tuple) data;\n        Object[] newValues = new Object[index];\n        Object[] newValues2 = new Object[this.values.length - index];\n        arraycopy(this.values, index, newValues2, 0, this.values.length - index);\n        tmp.setValues(newValues2);\n        arraycopy(this.values, 0, newValues, 0, index);\n        this.setValues(newValues);\n    }\n\n    /**\n     * Joins two tuples into one\n     *\n     * @param datas the tuples to join\n     * \n     */\n    @Override\n    public void join(Object... datas) {\n        for (Object data : datas) {\n            if (!isTuple(data)) {\n                continue;\n            }\n            Tuple tmp = (Tuple) data;\n            for (int i = 0; i < tmp.length(); i++) {\n                this.push(tmp.getValue(i));\n            }\n        }\n    }\n\n    /**\n     * Fills the array with the specified value.\n     *\n     * @param value the value to fill the array with\n     */\n    public <T> void fill(T value, int amount) {\n        if (amount < 0) { amount = 0; }\n        if (amount == 0 || value == null) { return; }\n        for (int i = 0; i < amount; i++) {\n            this.push(value);\n        }\n    }\n\n    /**\n     * Fills the array with random values.\n     *\n     * @param amount the amount of random values to generate\n     */\n    public void fillRandom(int amount) {\n        if (amount < 0 || amount > this.values.length) {\n            amount = 0;\n        }\n        if (amount == 0) {\n            return;\n        }\n        for (int i = 0; i < amount; i++) {\n            this.values[i] = random.nextInt(100);\n        }\n    }\n\n    /**\n     * Fills the values array with random integers between 0 and 99 (inclusive).\n     */\n    public void fillRandom(int min, int max, int amount) {\n        if (amount < 0 || amount > this.values.length) {\n            amount = 0;\n        }\n        if (amount == 0) {\n            return;\n        }\n        if (min > max) {\n            int tmp = min;\n            min = max;\n            max = tmp;\n        }\n        for (int i = 0; i < amount; i++) {\n\n            this.values[i] = random.nextInt(max - min + 1) + min;\n        }\n    }\n\n    /**\n     * Determines if this tuple is a subset of the given tuple.\n     *\n     * @param data the tuple to check against\n     * @return true if this tuple is a subset of the given tuple, false otherwise\n     */\n    @Override\n    public boolean isSubsetOf(Object data) throws IllegalArgumentException{\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (this.length() > ((Tuple) data).length()) {\n            return false;\n        }\n        Tuple tmp = (Tuple) data;\n        for (int i = 0; i < this.length(); i++) {\n            if (!tmp.contains(this.getValue(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Determines if this tuple is a superset of the given tuple.\n     *\n     * @param data the tuple to check against\n     * @return true if this tuple is a superset of the given tuple, false otherwise\n     */\n    @Override\n    public boolean isSupersetOf(Object data) throws IllegalArgumentException {\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (this.length() < ((Tuple) data).length()) {\n            return false;\n        }\n        Tuple tmp = (Tuple) data;\n        return tmp.isSubsetOf(this);\n    }\n\n    /**\n     * Determines if this set is a strict superset of the given tuple.\n     * A strict superset means that this set contains all the values\n     * of the given tuple in the same order\n     *\n     * @param data the tuple to compare against\n     * @return true if this set is a strict superset of the given tuple, false otherwise\n     */\n    public boolean isStrictSupersetOf(Object data) throws IllegalArgumentException {\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (this.length() < ((Tuple) data).length()) {\n            return false;\n        }\n        int consecutive = 0;\n        Tuple tmp = (Tuple) data;\n        for (int i = 0; i < tmp.length(); i++) {\n            if (this.contains(tmp.getValue(i))) {\n                consecutive++;\n            } else {\n                consecutive = 0;\n            }\n        }\n        return consecutive == tmp.length();\n    }\n\n    /**\n     * Determines if this set is a strict subset of the given tuple.\n     * A strict subset means that this set contains all the values\n     * of the given tuple in the same order\n     *\n     * @param data the tuple to compare against\n     * @return true if this set is a strict subset of the given tuple, false otherwise\n     */\n    public boolean isStrictSubsetOf(Object data) throws IllegalArgumentException{\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (this.length() > ((Tuple) data).length()) {\n            return false;\n        }\n        Tuple tmp = (Tuple) data;\n        int consecutive = 0;\n        for (int i = 0; i < this.length(); i++) {\n            if (tmp.contains(this.getValue(i))){\n                consecutive++;\n            } else {\n                consecutive = 0;\n            }\n        }\n        return consecutive == this.length();\n    }\n\n    /**\n     * Checks if the current tuple.Tuple is disjoint with the given tuple.Tuple.\n     *\n     * @param data the tuple.Tuple to check for disjointness\n     * @return true if the Tuples are disjoint, false otherwise\n     */\n    @Override\n    public boolean isDisjoint(Object data) throws IllegalArgumentException{\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        if (data.equals(this)) {\n            return false;\n        }\n        Tuple tmp = (Tuple) data;\n        for (int i = 0; i < tmp.length(); i++) {\n            if (this.contains(tmp.getValue(i))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the symmetric difference between this tuple and the given tuple\n     * The symmetric difference is the set of values that are in either tuple\n     * but not in both\n     *\n     * @param data the tuple\n     * @return the symmetric difference\n     */\n    public Object symmetricDifference(Object data) throws IllegalArgumentException {\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        Tuple tuple = (Tuple) data;\n        Tuple result = new Tuple();\n        for (int i = 0; i < this.length(); i++) {\n            if (!tuple.contains(this.getValue(i))) {\n                result.push(this.getValue(i));\n            }\n        }\n        for (int i = 0; i < tuple.length(); i++) {\n            if (!this.contains(tuple.getValue(i))) {\n                result.push(tuple.getValue(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Subtracts the given tuple from this tuple\n     *\n     * @param data the tuple\n     * @return the result\n     */\n    @Override\n    public Object subtract(Object data) throws IllegalArgumentException {\n        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }\n        Tuple tmp = (Tuple) data;\n        Tuple result = new Tuple();\n        for (int i = 0; i < this.length(); i++) {\n            if (!tmp.contains(this.getValue(i))){\n                result.push(this.getValue(i));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Filters the elements of the tuple.Tuple based on the given predicate.\n     *\n     * @param predicate the predicate used to filter the elements of the tuple.Tuple\n     * @return the filtered tuple.Tuple\n     */\n    @Override\n    public Object filter(Predicate<Object> predicate){\n        Tuple result = new Tuple();\n        IntStream.range(\n                0,\n                this.length()\n        )\n        .filter(\n            i -> predicate.test(this.getValue(i))\n        ).mapToObj(\n                this::getValue\n        ).forEachOrdered(result::push);\n\n        return result;\n    }\n\n    /**\n     * Returns an iterator over elements of type {@code T}.\n     *\n     * @return an Iterator.\n     */\n    @Override\n    public Iterator<Object> iterator() {\n        return new Iterator<>() {\n            private int currentIndex = 0;\n\n            @Override\n            public boolean hasNext() {\n                return currentIndex < length() && values[currentIndex] != null;\n            }\n\n            @Override\n            public Object next() {\n                if (!hasNext()) { throw new NoSuchElementException(); }\n                return values[currentIndex++];\n            }\n        };\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Tuple.java b/src/main/java/ch/mazluc/data/Tuple.java
--- a/src/main/java/ch/mazluc/data/Tuple.java	(revision 7514c215d7b40b9bbd76c696b7fae4d7fcd65836)
+++ b/src/main/java/ch/mazluc/data/Tuple.java	(date 1704219101553)
@@ -31,10 +31,6 @@
  * SOFTWARE.
  */
 /**
- * <h1>
- * Tuple
- * </h1>
- *
  * <p>
  * This class represents a tuple of values.
  * A tuple is a sequence of values that can be
Index: src/main/java/ch/mazluc/data/Table.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.mazluc.data;\n\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.function.Predicate;\n\nimport static java.lang.System.arraycopy;\n/*\n * MIT License\n *\n * Copyright (c) 2023 Luca Mazza\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/**\n * <h1>\n * Table\n * </h1>\n *\n * <p>\n * Represents a table.\n * A table is a collection of tuples.\n * Allows to iterate through the tuples and to run\n * some different operations on the tuples.\n * It is an implementation of the {@link Data} interface.\n *\n * <p>\n * Usage:\n * <pre>\n * {@code\n * Data table = new Table();\n * table.push(new Tuple(1, 2));\n * table.push(new Tuple(3, 4));\n * table.delete(0);\n * table.push(new Tuple(5, 6));\n * table.push(new Tuple(7, 8));\n * table.slice(1, 2);\n * }\n * </pre>\n *\n * <p>\n * See Repo for more: <a href=\"https://github.com/lucamazzza/BData\">GitHub</a>\n *\n * @author Luca Mazza\n * @version 1.0\n */\npublic class Table implements Data{\n\n    /**\n     * Message when an index is out of bounds\n     */\n    private static final String IOOBE = \"Index out of bounds for length \";\n\n    /**\n     * Message when an object is not a table\n     */\n    private static final String OINAT = \"Object is not a table\";\n\n    /**\n     * The values of the table\n     */\n    private Tuple[] values;\n\n    /**\n     * Creates a new, empty table\n     */\n    public Table(){\n        this.values = new Tuple[0];\n    }\n\n    /**\n     * Creates a new table with the specified values\n     * @param values the values\n     */\n    public Table(Tuple... values){\n        this.values = values;\n    }\n\n    private static boolean isTable(Object o) {\n        return o.getClass() == Table.class;\n    }\n\n    /**\n     * Retrieves the length of the object.\n     *\n     * @return the length of the object.\n     */\n    @Override\n    public int length() {\n        return this.values.length;\n    }\n\n    /**\n     * Checks if the object is empty.\n     *\n     * @return true if the object is empty, false otherwise\n     */\n    @Override\n    public boolean isEmpty() {\n        return this.values.length == 0;\n    }\n\n    @Override\n    public boolean equals(Object o) throws IllegalArgumentException {\n        if (!isTable(o)) { throw new IllegalArgumentException(OINAT); }\n        Table table = (Table) o;\n        if (this.length() != table.length()) {\n            return false;\n        }\n        for (int i = 0; i < this.length(); i++) {\n            if (!this.values[i].equals(table.values[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int hashCode = 0;\n        for (Tuple value : this.values) {\n            hashCode += value.hashCode();\n        }\n        return hashCode;\n    }\n\n    /**\n     * Determines whether the function contains the specified value.\n     *\n     * @param value the value to be checked if it is contained in the function\n     * @return true if the value is contained in the function, otherwise false\n     */\n    @Override\n    public <T> boolean contains(T value) {\n        if (this.isEmpty()) { return false; }\n        if (Tuple.isTuple(value)) {\n            for (Tuple tuple : this.values) {\n                if (tuple.equals(value)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        for (Tuple tuple : this.values) {\n            if (tuple.contains(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Sets the values of the collection.\n     *\n     * @param values an array of values to be set\n     */\n    @SafeVarargs\n    public final <T> void setValues(T... values) {\n        this.clear();\n        for (T value : values) {\n            if (value == null) {\n                continue;\n            }\n            this.push(value);\n        }\n    }\n\n    /**\n     * Pushes a value onto the collection.\n     *\n     * @param value the value to be pushed onto the stack\n     */\n    @Override\n    public <T> void push(T value) throws IllegalArgumentException {\n        if (this.values.length == 0) {\n            this.values = new Tuple[1];\n            this.values[0] = (value instanceof Tuple t) ? t : new Tuple(value);\n            return;\n        }\n        Tuple[] tmp = new Tuple[this.length() + 1];\n        arraycopy(this.values, 0, tmp, 0, this.length());\n        tmp[tmp.length - 1] = (value instanceof Tuple t) ? t : new Tuple(value);\n        this.values = tmp;\n    }\n\n    /**\n     * Inserts a new value at the specified index\n     *\n     * @param row index to insert the value into\n     * @param col index to insert the value into\n     * @param value value to insert\n     */\n    public <T> void insert(int row, int col, T value) throws IndexOutOfBoundsException {\n        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {\n            throw new IndexOutOfBoundsException(IOOBE + this.values.length);\n        }\n        this.values[row].insert(col, value);\n    }\n\n    /**\n     * Replaces the element at the specified index with the given value.\n     *\n     * @param row the index of the element to be replaced\n     * @param col the index of the element to be replaced\n     * @param value the value to replace the element with\n     */\n    public <T> void replace(int row, int col, T value) throws IndexOutOfBoundsException {\n        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {\n            throw new IndexOutOfBoundsException(IOOBE + this.values.length);\n        }\n        this.values[row].replace(col, value);\n    }\n\n    /**\n     * Swaps the rows at the specified indices in the array.\n     *\n     * @param index1 the index of the first element to be swapped\n     * @param index2 the index of the second element to be swapped\n     */\n    @Override\n    public void swap(int index1, int index2) throws IndexOutOfBoundsException {\n        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {\n            throw new IndexOutOfBoundsException(IOOBE + this.values.length);\n        }\n        Tuple temp = this.values[index1];\n        this.values[index1] = this.values[index2];\n        this.values[index2] = temp;\n    }\n\n    /**\n     * Retrieves the value at the specified index.\n     *\n     * @param row the index of the value\n     * @param col the index of the value\n     * @return the value at the specified index\n     */\n    public <T> T getValue(int row, int col) throws IndexOutOfBoundsException {\n        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {\n            throw new IndexOutOfBoundsException(IOOBE + this.values.length);\n        }\n        return this.values[row].getValue(col);\n    }\n\n    /**\n     * Returns the index of a specified value\n     *\n     * @param value the value to search\n     * @return the index of the value\n     */\n    public <T> int[] indexOf(T value) {\n        int[] coordinates = new int[2];\n        for (int i = 0; i < this.values.length; i++) {\n            for (int j = 0; j < this.values[i].length(); j++) {\n                if (this.values[i].getValue(j).equals(value)) {\n                    coordinates[0] = i;\n                    coordinates[1] = j;\n                    return coordinates;\n                }\n            }\n        }\n        return coordinates;\n    }\n\n    /**\n     * Removes the value at the last index\n     */\n    @Override\n    public void pop() {\n        if (this.values.length == 0) {\n            return;\n        }\n        Tuple[] newValues = new Tuple[this.values.length - 1];\n        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);\n        this.values = newValues;\n    }\n\n    /**\n     * Removes the element at the specified index\n     *\n     * @param row the index of the element to be removed\n     * @param col the index of the element to be removed\n     */\n    public void remove(int row, int col) throws IndexOutOfBoundsException {\n        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {\n            throw new IndexOutOfBoundsException(IOOBE + this.values.length);\n        }\n        this.values[row].remove(col);\n    }\n\n    /**\n     * Clears the table\n     */\n    @Override\n    public void clear() {\n        this.values = new Tuple[0];\n    }\n\n    /**\n     * Slice the table from a defined row to a defined row\n     *\n     * @param start the index to start\n     * @param end   the index to end\n     */\n    @Override\n    public void slice(int start, int end) {\n        if (end > this.values.length) {\n            end = this.values.length;\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        Tuple[] newValues = new Tuple[end - start];\n        arraycopy(this.values, start, newValues, 0, newValues.length);\n        this.values = newValues;\n    }\n\n    /**\n     * Joins two or more tables\n     *\n     * @param datas the tables to join\n     */\n    @Override\n    public void join(Object... datas) {\n        for (Object data : datas) {\n            if (!isTable(data)) { continue; }\n            for (Tuple value : ((Table) data).values) {\n                this.push(value);\n            }\n        }\n    }\n\n    /**\n     * Returns true if this table is a subset of the given table\n     *\n     * @param data the table\n     * @return true if this table is a subset of the given table\n     */\n    @Override\n    public boolean isSubsetOf(Object data) throws IllegalArgumentException {\n        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }\n        Table table = (Table) data;\n        if (this.length() > table.length()) {\n            return false;\n        }\n        int count = 0;\n        for (int i = 0; i < table.length(); i++) {\n            if (this.contains(table.values[i])) {\n                count++;\n            }\n        }\n        return count == this.length();\n\n    }\n\n    /**\n     * Returns true if this table is a superset of the given table\n     *\n     * @param data the table\n     * @return true if this table is a superset of the given table\n     */\n    @Override\n    public boolean isSupersetOf(Object data) throws IllegalArgumentException {\n        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }\n        Table table = (Table) data;\n        return table.isSubsetOf(this);\n    }\n\n\n    /**\n     * Subtracts the given table from this table\n     *\n     * @param data the table\n     * @return the difference\n     */\n    @Override\n    public Object subtract(Object data) {\n        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }\n        Table tmp = new Table();\n        Table table = (Table) data;\n        for (Tuple value : this.values) {\n            if (!table.contains(value)) {\n                tmp.push(value);\n            }\n        }\n        return tmp;\n    }\n\n    /**\n     * Filters the table using `Predicates`\n     * Returns the Tuples containing the values that match the predicate\n     *\n     * @param predicate the predicate\n     * @return the filtered table\n     */\n    @Override\n    public Object filter(Predicate<Object> predicate) {\n        Tuple result = new Tuple();\n        for (Tuple value : this.values) {\n            if(!((Tuple)value.filter(predicate)).isEmpty()) {\n                result.join(value.filter(predicate));\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns true if this table is disjoint from the given table\n     * Disjunction is the set of values that are in either table\n     * but not in both\n     *\n     * @param data the table\n     * @return true if this table is disjoint from the given table\n     */\n    @Override\n    public boolean isDisjoint(Object data) {\n        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }\n        Table table = (Table) data;\n        for (Tuple value : table.values) {\n            for (int i = 0; i < value.length(); i++) {\n                if (this.contains(value.getValue(i))) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder out = new StringBuilder();\n        for (Object value : this.values) out.append(value).append(\"\\n\");\n        return out.toString();\n    }\n\n    /**\n     * Returns an iterator over elements of type {@code T}.\n     *\n     * @return an Iterator.\n     */\n    @Override\n    public Iterator<Object> iterator() {\n        return new Iterator<>() {\n            private int currentIndex = 0;\n\n            @Override\n            public boolean hasNext() {\n                return currentIndex < length() && values[currentIndex] != null;\n            }\n\n            @Override\n            public Tuple next() throws NoSuchElementException {\n                if (!hasNext()) { throw new NoSuchElementException(); }\n                return values[currentIndex++];\n            }\n        };\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Table.java b/src/main/java/ch/mazluc/data/Table.java
--- a/src/main/java/ch/mazluc/data/Table.java	(revision b6ae28ce1e9f9de0f27c1d77a2eea8c9eab0fd5b)
+++ b/src/main/java/ch/mazluc/data/Table.java	(date 1704219416894)
@@ -28,10 +28,6 @@
  * SOFTWARE.
  */
 /**
- * <h1>
- * Table
- * </h1>
- *
  * <p>
  * Represents a table.
  * A table is a collection of tuples.
@@ -64,12 +60,12 @@
     /**
      * Message when an index is out of bounds
      */
-    private static final String IOOBE = "Index out of bounds for length ";
+    private static final String OUT_OF_BOUNDS = "Index out of bounds for length ";
 
     /**
      * Message when an object is not a table
      */
-    private static final String OINAT = "Object is not a table";
+    private static final String NOT_A_TABLE = "Object is not a table";
 
     /**
      * The values of the table
@@ -92,7 +88,7 @@
     }
 
     private static boolean isTable(Object o) {
-        return o.getClass() == Table.class;
+        return Table.class == o.getClass();
     }
 
     /**
@@ -117,17 +113,18 @@
 
     @Override
     public boolean equals(Object o) throws IllegalArgumentException {
-        if (!isTable(o)) { throw new IllegalArgumentException(OINAT); }
-        Table table = (Table) o;
-        if (this.length() != table.length()) {
-            return false;
-        }
-        for (int i = 0; i < this.length(); i++) {
-            if (!this.values[i].equals(table.values[i])) {
-                return false;
-            }
-        }
-        return true;
+        if (isTable(o)) {
+            Table table = (Table) o;
+            if (this.length() != table.length()) {
+                return false;
+            }
+            for (int i = 0; i < this.length(); i++) {
+                if (!this.values[i].equals(table.values[i])) {
+                    return false;
+                }
+            }
+            return true;
+        } else throw new IllegalArgumentException(NOT_A_TABLE);
     }
 
     @Override
@@ -207,7 +204,7 @@
      */
     public <T> void insert(int row, int col, T value) throws IndexOutOfBoundsException {
         if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
+            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
         }
         this.values[row].insert(col, value);
     }
@@ -221,7 +218,7 @@
      */
     public <T> void replace(int row, int col, T value) throws IndexOutOfBoundsException {
         if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
+            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
         }
         this.values[row].replace(col, value);
     }
@@ -235,7 +232,7 @@
     @Override
     public void swap(int index1, int index2) throws IndexOutOfBoundsException {
         if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
+            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
         }
         Tuple temp = this.values[index1];
         this.values[index1] = this.values[index2];
@@ -251,7 +248,7 @@
      */
     public <T> T getValue(int row, int col) throws IndexOutOfBoundsException {
         if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
+            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
         }
         return this.values[row].getValue(col);
     }
@@ -297,7 +294,7 @@
      */
     public void remove(int row, int col) throws IndexOutOfBoundsException {
         if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
+            throw new IndexOutOfBoundsException(OUT_OF_BOUNDS + this.values.length);
         }
         this.values[row].remove(col);
     }
@@ -352,7 +349,7 @@
      */
     @Override
     public boolean isSubsetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
+        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
         Table table = (Table) data;
         if (this.length() > table.length()) {
             return false;
@@ -375,7 +372,7 @@
      */
     @Override
     public boolean isSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
+        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
         Table table = (Table) data;
         return table.isSubsetOf(this);
     }
@@ -389,7 +386,7 @@
      */
     @Override
     public Object subtract(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
+        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
         Table tmp = new Table();
         Table table = (Table) data;
         for (Tuple value : this.values) {
@@ -428,7 +425,7 @@
      */
     @Override
     public boolean isDisjoint(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
+        if (!isTable(data)) { throw new IllegalArgumentException(NOT_A_TABLE); }
         Table table = (Table) data;
         for (Tuple value : table.values) {
             for (int i = 0; i < value.length(); i++) {
Index: src/main/java/ch/mazluc/data/Data.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package ch.mazluc.data;\n\nimport java.util.function.Predicate;\n/*\n * MIT License\n *\n * Copyright (c) 2023 Luca Mazza\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/**\n * <h1>\n * Data\n * </h1>\n *\n * <p>\n * Represents a data structure.\n * A data structure is a collection of values.\n * It is an extension of the {@link Iterable} interface.\n *\n * <p>\n * Usage:\n *\n * <pre>\n * {@code\n * \n * }\n * </pre>\n *\n * <p>\n * See Repo for more: <a href=\"https://github.com/lucamazzza/BData\">GitHub</a>\n *\n * @author Luca Mazza\n * @version 1.0\n */\npublic interface Data extends Iterable<Object> {\n\n    /**\n     * Retrieves the length of the object.\n     *\n     * @return the length of the object.\n     */\n    int length();\n\n    /**\n     * Checks if the object is empty.\n     *\n     * @return true if the object is empty, false otherwise\n     */\n    boolean isEmpty();\n\n    /**\n     * Determines whether the function contains the specified value.\n     *\n     * @param value the value to be checked if it is contained in the function\n     * @return true if the value is contained in the function, otherwise false\n     * @param <T> the type\n     */\n    <T>boolean contains(T value);\n\n    /**\n     * Pushes a value onto the collection.\n     *\n     * @param value the value to be pushed onto the stack\n     * @param <T> the type\n     */\n    <T> void push(T value);\n\n    /**\n     * Swaps the elements at the specified indices in the array.\n     *\n     * @param index1 the index of the first element to be swapped\n     * @param index2 the index of the second element to be swapped\n     */\n    void swap(int index1, int index2) throws IndexOutOfBoundsException;\n\n    /**\n     * Removes the value at the last index\n     */\n    void pop();\n\n    /**\n     * Clears the array\n     */\n    void clear();\n\n    /**\n     * Slice the collection from a defined start to a defined end\n     *\n     * @param start the index to start\n     * @param end   the index to end\n     */\n    void slice(int start, int end);\n\n    /**\n     * Joins two or more tuples\n     *\n     * @param datas the tuples to join\n     */\n    void join(Object... datas);\n\n    /**\n     * Returns true if this tuple is a subset of the given tuple\n     *\n     * @param data the tuple\n     * @return true if this tuple is a subset of the given tuple\n     */\n    boolean isSubsetOf(Object data);\n\n    /**\n     * Returns true if this tuple is a superset of the given tuple\n     *\n     * @param data the tuple\n     * @return true if this tuple is a superset of the given tuple\n     */\n    boolean isSupersetOf(Object data);\n\n    /**\n     * Subtracts the given tuple from this tuple\n     *\n     * @param data the tuple\n     * @return the difference\n     */\n    Object subtract(Object data);\n\n    /**\n     * Filters the tuple using `Predicates`\n     *\n     * @param predicate the predicate\n     * @return the filtered tuple\n     */\n    Object filter(Predicate<Object> predicate);\n\n    /**\n     * Returns true if this tuple is disjoint from the given tuple\n     * Disjunction is the set of values that are in either tuple\n     * but not in both\n     *\n     * @param data the tuple\n     * @return true if this tuple is disjoint from the given tuple\n     */\n    boolean isDisjoint(Object data);\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ch/mazluc/data/Data.java b/src/main/java/ch/mazluc/data/Data.java
--- a/src/main/java/ch/mazluc/data/Data.java	(revision 7514c215d7b40b9bbd76c696b7fae4d7fcd65836)
+++ b/src/main/java/ch/mazluc/data/Data.java	(date 1704219101545)
@@ -24,10 +24,6 @@
  * SOFTWARE.
  */
 /**
- * <h1>
- * Data
- * </h1>
- *
  * <p>
  * Represents a data structure.
  * A data structure is a collection of values.
