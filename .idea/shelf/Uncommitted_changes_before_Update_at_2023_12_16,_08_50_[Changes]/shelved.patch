Index: src/main/java/ch/mazluc/Data.java
===================================================================
diff --git a/src/main/java/ch/mazluc/Data.java b/src/main/java/ch/mazluc/Data.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/Data.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,119 +0,0 @@
-package ch.mazluc;
-
-import java.util.function.Predicate;
-
-/**
- * This interface represents a collection of values
- *
- * @author Luca Mazza
- * @version 1.0
- * @since 1.0
- */
-public interface Data extends Iterable<Object> {
-
-    /**
-     * Retrieves the length of the object.
-     *
-     * @return the length of the object.
-     */
-    int length();
-
-    /**
-     * Checks if the object is empty.
-     *
-     * @return true if the object is empty, false otherwise
-     */
-    boolean isEmpty();
-
-    /**
-     * Determines whether the function contains the specified value.
-     *
-     * @param value the value to be checked if it is contained in the function
-     * @return true if the value is contained in the function, otherwise false
-     * @param <T> the type
-     */
-    <T>boolean contains(T value);
-
-    /**
-     * Pushes a value onto the collection.
-     *
-     * @param value the value to be pushed onto the stack
-     * @param <T> the type
-     */
-    <T> void push(T value);
-
-    /**
-     * Swaps the elements at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     */
-    void swap(int index1, int index2) throws IndexOutOfBoundsException;
-
-    /**
-     * Removes the value at the last index
-     */
-    void pop();
-
-    /**
-     * Clears the array
-     */
-    void clear();
-
-    /**
-     * Slice the collection from a defined start to a defined end
-     *
-     * @param start the index to start
-     * @param end   the index to end
-     */
-    void slice(int start, int end);
-
-    /**
-     * Joins two or more tuples
-     *
-     * @param datas the tuples to join
-     */
-    void join(Object... datas);
-
-    /**
-     * Returns true if this tuple is a subset of the given tuple
-     *
-     * @param data the tuple
-     * @return true if this tuple is a subset of the given tuple
-     */
-    boolean isSubsetOf(Object data);
-
-    /**
-     * Returns true if this tuple is a superset of the given tuple
-     *
-     * @param data the tuple
-     * @return true if this tuple is a superset of the given tuple
-     */
-    boolean isSupersetOf(Object data);
-
-    /**
-     * Subtracts the given tuple from this tuple
-     *
-     * @param data the tuple
-     * @return the difference
-     */
-    Object subtract(Object data);
-
-    /**
-     * Filters the tuple using `Predicates`
-     *
-     * @param predicate the predicate
-     * @return the filtered tuple
-     */
-    Object filter(Predicate<Object> predicate);
-
-    /**
-     * Returns true if this tuple is disjoint from the given tuple
-     * Disjunction is the set of values that are in either tuple
-     * but not in both
-     *
-     * @param data the tuple
-     * @return true if this tuple is disjoint from the given tuple
-     */
-    boolean isDisjoint(Object data);
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/Table.java
===================================================================
diff --git a/src/main/java/ch/mazluc/Table.java b/src/main/java/ch/mazluc/Table.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/Table.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,441 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-import java.util.function.Predicate;
-
-import static java.lang.System.arraycopy;
-
-/**
- * Represents a table
- *
- * @author Luca Mazza
- * @version 1.0
- * @since 1.0
- */
-public class Table implements Data{
-
-    private static final String IOOBE = "Index out of bounds for length ";
-    private static final String OINAT = "Object is not a table";
-
-    /**
-     * The values of the table
-     */
-    private Tuple[] values;
-
-    /**
-     * Creates a new, empty table
-     */
-    public Table(){
-        this.values = new Tuple[0];
-    }
-
-    /**
-     * Creates a new table with the specified values
-     * @param values the values
-     */
-    public Table(Tuple... values){
-        this.values = values;
-    }
-
-    private static boolean isTable(Object o) {
-        return o.getClass() == Table.class;
-    }
-
-    /**
-     * Retrieves the length of the object.
-     *
-     * @return the length of the object.
-     */
-    @Override
-    public int length() {
-        return this.values.length;
-    }
-
-    /**
-     * Checks if the object is empty.
-     *
-     * @return true if the object is empty, false otherwise
-     */
-    @Override
-    public boolean isEmpty() {
-        return this.values.length == 0;
-    }
-
-    @Override
-    public boolean equals(Object o) throws IllegalArgumentException {
-        if (!isTable(o)) { throw new IllegalArgumentException(OINAT); }
-        Table table = (Table) o;
-        if (this.length() != table.length()) {
-            return false;
-        }
-        for (int i = 0; i < this.length(); i++) {
-            if (!this.values[i].equals(table.values[i])) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        int hashCode = 0;
-        for (Tuple value : this.values) {
-            hashCode += value.hashCode();
-        }
-        return hashCode;
-    }
-
-    /**
-     * Determines whether the function contains the specified value.
-     *
-     * @param value the value to be checked if it is contained in the function
-     * @return true if the value is contained in the function, otherwise false
-     */
-    @Override
-    public <T> boolean contains(T value) {
-        if (this.isEmpty()) { return false; }
-        if (Tuple.isTuple(value)) {
-            for (Tuple tuple : this.values) {
-                if (tuple.equals(value)) {
-                    return true;
-                }
-            }
-            return false;
-        }
-        for (Tuple tuple : this.values) {
-            if (tuple.contains(value)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Sets the values of the collection.
-     *
-     * @param values an array of values to be set
-     */
-    @SafeVarargs
-    public final <T> void setValues(T... values) {
-        this.clear();
-        for (T value : values) {
-            if (value == null) {
-                continue;
-            }
-            this.push(value);
-        }
-    }
-
-    /**
-     * Pushes a value onto the collection.
-     *
-     * @param value the value to be pushed onto the stack
-     */
-    @Override
-    public <T> void push(T value) throws IllegalArgumentException {
-        if (this.values.length == 0) {
-            this.values = new Tuple[1];
-            this.values[0] = (value instanceof Tuple t) ? t : new Tuple(value);
-            return;
-        }
-        Tuple[] tmp = new Tuple[this.length() + 1];
-        arraycopy(this.values, 0, tmp, 0, this.length());
-        tmp[tmp.length - 1] = (value instanceof Tuple t) ? t : new Tuple(value);
-        this.values = tmp;
-    }
-
-    /**
-     * Inserts a new value at the specified index
-     *
-     * @param row index to insert the value into
-     * @param col index to insert the value into
-     * @param value value to insert
-     */
-    public <T> void insert(int row, int col, T value) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
-        }
-        this.values[row].insert(col, value);
-    }
-
-    /**
-     * Replaces the element at the specified index with the given value.
-     *
-     * @param row the index of the element to be replaced
-     * @param col the index of the element to be replaced
-     * @param value the value to replace the element with
-     */
-    public <T> void replace(int row, int col, T value) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
-        }
-        this.values[row].replace(col, value);
-    }
-
-    /**
-     * Swaps the rows at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     */
-    @Override
-    public void swap(int index1, int index2) throws IndexOutOfBoundsException {
-        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
-        }
-        Tuple temp = this.values[index1];
-        this.values[index1] = this.values[index2];
-        this.values[index2] = temp;
-    }
-
-    /**
-     * Retrieves the value at the specified index.
-     *
-     * @param row the index of the value
-     * @param col the index of the value
-     * @return the value at the specified index
-     */
-    public <T> T getValue(int row, int col) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
-        }
-        return this.values[row].getValue(col);
-    }
-
-    /**
-     * Returns the index of a specified value
-     *
-     * @param value the value to search
-     * @return the index of the value
-     */
-    public <T> int[] indexOf(T value) {
-        int[] coordinates = new int[2];
-        for (int i = 0; i < this.values.length; i++) {
-            for (int j = 0; j < this.values[i].length(); j++) {
-                if (this.values[i].getValue(j).equals(value)) {
-                    coordinates[0] = i;
-                    coordinates[1] = j;
-                    return coordinates;
-                }
-            }
-        }
-        return coordinates;
-    }
-
-    /**
-     * Removes the value at the last index
-     */
-    @Override
-    public void pop() {
-        if (this.values.length == 0) {
-            return;
-        }
-        Tuple[] newValues = new Tuple[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);
-        this.values = newValues;
-    }
-
-    /**
-     * Removes the element at the specified index
-     *
-     * @param row the index of the element to be removed
-     * @param col the index of the element to be removed
-     */
-    public void remove(int row, int col) throws IndexOutOfBoundsException {
-        if (row < 0 || row >= this.values.length || col < 0 || col >= this.values[row].length()) {
-            throw new IndexOutOfBoundsException(IOOBE + this.values.length);
-        }
-        this.values[row].remove(col);
-    }
-
-    /**
-     * Clears the table
-     */
-    @Override
-    public void clear() {
-        this.values = new Tuple[0];
-    }
-
-    /**
-     * Slice the table from a defined row to a defined row
-     *
-     * @param start the index to start
-     * @param end   the index to end
-     */
-    @Override
-    public void slice(int start, int end) {
-        if (end > this.values.length) {
-            end = this.values.length;
-        }
-        if (start < 0) {
-            start = 0;
-        }
-        Tuple[] newValues = new Tuple[end - start];
-        arraycopy(this.values, start, newValues, 0, newValues.length);
-        this.values = newValues;
-    }
-
-    /**
-     * Joins two or more tables
-     *
-     * @param datas the tables to join
-     */
-    @Override
-    public void join(Object... datas) {
-        for (Object data : datas) {
-            if (!isTable(data)) { continue; }
-            for (Tuple value : ((Table) data).values) {
-                this.push(value);
-            }
-        }
-    }
-
-    /**
-     * Returns true if this table is a subset of the given table
-     *
-     * @param data the table
-     * @return true if this table is a subset of the given table
-     */
-    @Override
-    public boolean isSubsetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
-        Table table = (Table) data;
-        if (this.length() > table.length()) {
-            return false;
-        }
-        int count = 0;
-        for (int i = 0; i < table.length(); i++) {
-            if (this.contains(table.values[i])) {
-                count++;
-            }
-        }
-        return count == this.length();
-
-    }
-
-    /**
-     * Returns true if this table is a superset of the given table
-     *
-     * @param data the table
-     * @return true if this table is a superset of the given table
-     */
-    @Override
-    public boolean isSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
-        Table table = (Table) data;
-        return table.isSubsetOf(this);
-    }
-
-
-    /**
-     * Subtracts the given table from this table
-     *
-     * @param data the table
-     * @return the difference
-     */
-    @Override
-    public Object subtract(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
-        Table tmp = new Table();
-        Table table = (Table) data;
-        for (Tuple value : this.values) {
-            if (!table.contains(value)) {
-                tmp.push(value);
-            }
-        }
-        return tmp;
-    }
-
-    /**
-     * Filters the table using `Predicates`
-     * Returns the Tuples containing the values that match the predicate
-     *
-     * @param predicate the predicate
-     * @return the filtered table
-     */
-    @Override
-    public Object filter(Predicate<Object> predicate) {
-        Tuple result = new Tuple();
-        for (Tuple value : this.values) {
-            if(!((Tuple)value.filter(predicate)).isEmpty()) {
-                result.join(value.filter(predicate));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Returns true if this table is disjoint from the given table
-     * Disjunction is the set of values that are in either table
-     * but not in both
-     *
-     * @param data the table
-     * @return true if this table is disjoint from the given table
-     */
-    @Override
-    public boolean isDisjoint(Object data) {
-        if (!isTable(data)) { throw new IllegalArgumentException(OINAT); }
-        Table table = (Table) data;
-        for (Tuple value : table.values) {
-            for (int i = 0; i < value.length(); i++) {
-                if (this.contains(value.getValue(i))) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        StringBuilder out = new StringBuilder();
-        for (Object value : this.values) out.append(value).append("\n");
-        return out.toString();
-    }
-
-    /**
-     * Returns an iterator over elements of type {@code T}.
-     *
-     * @return an Iterator.
-     */
-    @Override
-    public Iterator<Object> iterator() {
-        return new Iterator<>() {
-            private int currentIndex = 0;
-
-            @Override
-            public boolean hasNext() {
-                return currentIndex < length() && values[currentIndex] != null;
-            }
-
-            @Override
-            public Tuple next() throws NoSuchElementException {
-                if (!hasNext()) { throw new NoSuchElementException(); }
-                return values[currentIndex++];
-            }
-        };
-    }
-}
Index: src/test/java/ch/mazluc/TupleTest.java
===================================================================
diff --git a/src/test/java/ch/mazluc/TupleTest.java b/src/test/java/ch/mazluc/TupleTest.java
deleted file mode 100644
--- a/src/test/java/ch/mazluc/TupleTest.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,409 +0,0 @@
-package ch.mazluc;
-import org.junit.jupiter.api.Test;
-
-import java.math.BigInteger;
-
-import static org.junit.jupiter.api.Assertions.*;
-class TupleTest {
-
-    @Test
-    void length() {
-        Tuple tuple = new Tuple();
-        assertEquals(0, tuple.length());
-        tuple.push(1);
-        assertEquals(1, tuple.length());
-        tuple.push(2);
-        assertEquals(2, tuple.length());
-        tuple.push(3);
-        assertEquals(3, tuple.length());
-    }
-
-    @Test
-    void isEmpty() {
-        Tuple tuple = new Tuple();
-        assertTrue(tuple.isEmpty());
-        tuple.push(1);
-        assertFalse(tuple.isEmpty());
-        tuple.pop();
-        assertTrue(tuple.isEmpty());
-    }
-
-    @Test
-    void testEquals() {
-        Data tuple = new Tuple();
-        Data tuple2 = new Tuple();
-        tuple.push(1);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(1);
-        assertEquals(tuple, tuple2);
-        tuple.push(2);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(2);
-        assertEquals(tuple, tuple2);
-        tuple.push(3);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(3);
-        assertEquals(tuple, tuple2);
-        tuple.push(4);
-        assertNotEquals(tuple, tuple2);
-        tuple2.push(4);
-        assertEquals(tuple, tuple2);
-    }
-
-    @Test
-    void contains() {
-        Data tuple = new Tuple(1);
-        tuple.push(1);
-        assertTrue(tuple.contains(1));
-        assertFalse(tuple.contains(2));
-    }
-
-    @Test
-    void containsType() {
-        Tuple tuple = new Tuple(1);
-        tuple.push(1);
-        assertTrue(tuple.containsType(Integer.class));
-        assertFalse(tuple.containsType(String.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push(null);
-        assertFalse(tuple.containsType(Object.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push("test");
-        assertTrue(tuple.containsType(String.class));
-        assertFalse(tuple.containsType(Boolean.class));
-        tuple.push(true);
-        assertTrue(tuple.containsType(Boolean.class));
-    }
-
-    @Test
-    void setValues() {
-        Tuple tuple = new Tuple();
-        tuple.setValues(1, 2, 3, 4, 5);
-        assertEquals(5, tuple.length());
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertEquals(4, (int)tuple.getValue(3));
-        assertEquals(5, (int)tuple.getValue(4));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-        assertNotEquals(8, (int)tuple.getValue(3));
-        assertNotEquals(1, (int)tuple.getValue(4));
-    }
-
-    @Test
-    void push() {
-        Tuple tuple = new Tuple();
-        tuple.push(1);
-        tuple.push(2);
-        tuple.push(3);
-        assertEquals(3, tuple.length());
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void insert() {
-        Tuple tuple = new Tuple(0);
-        tuple.insert(0, 2);
-        tuple.insert(2, 3);
-        assertEquals(3, tuple.length());
-        assertEquals(2, (int)tuple.getValue(0));
-        assertEquals(0, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(0, (int)tuple.getValue(0));
-        assertNotEquals(3, (int)tuple.getValue(1));
-        assertNotEquals(2, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void replace() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        tuple.replace(0, 1);
-        tuple.replace(1, 2);
-        tuple.replace(2, 3);
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void swap() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        tuple.swap(0, 1);
-        tuple.swap(1, 2);
-        tuple.swap(2, 3);
-        assertEquals(1, (int)tuple.getValue(0));
-        assertEquals(2, (int)tuple.getValue(1));
-        assertEquals(3, (int)tuple.getValue(2));
-        assertNotEquals(2, (int)tuple.getValue(0));
-        assertNotEquals(1, (int)tuple.getValue(1));
-        assertNotEquals(5, (int)tuple.getValue(2));
-    }
-
-    @Test
-    void getValue() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", false);
-        assertEquals(0, (int)tuple.getValue(0));
-        assertEquals(1, (int)tuple.getValue(1));
-        assertEquals(2, (int)tuple.getValue(2));
-        assertEquals(3, (int)tuple.getValue(3));
-        assertEquals(4, (int)tuple.getValue(4));
-        assertEquals(5, (int)tuple.getValue(5));
-        assertEquals(6, (int)tuple.getValue(6));
-        assertEquals(7, (int)tuple.getValue(7));
-        assertEquals(8, (int)tuple.getValue(8));
-        assertEquals(9, (int)tuple.getValue(9));
-        assertEquals("2", tuple.getValue(10));
-        assertEquals(false, tuple.getValue(11));
-    }
-
-    @Test
-    void getValuesOfType() {
-        BigInteger s = new BigInteger("12345678901234567890123456789012345678901234567890");
-        Tuple tuple = new Tuple(1, 2, 3, 4.0f, 5.5, 5.65, "Ciao", false, null, s);
-        assertEquals(tuple.getValuesOfType(Integer.class), new Tuple(1, 2, 3));
-        assertTrue(tuple.getValuesOfType(Float.class).contains(4.0f));
-        assertTrue(tuple.getValuesOfType(Double.class).contains(5.5));
-        assertEquals(tuple.getValuesOfType(String.class), new Tuple("Ciao"));
-        assertTrue(tuple.getValuesOfType(BigInteger.class).contains(s));
-    }
-
-    @Test
-    void indexOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        assertEquals(0, tuple.indexOf(0));
-        assertEquals(1, tuple.indexOf(1));
-        assertEquals(2, tuple.indexOf(2));
-        assertEquals(3, tuple.indexOf(3));
-        assertEquals(4, tuple.indexOf(4));
-        assertEquals(5, tuple.indexOf(5));
-        assertEquals(6, tuple.indexOf(6));
-        assertEquals(7, tuple.indexOf(7));
-        assertEquals(8, tuple.indexOf(8));
-        assertEquals(9, tuple.indexOf(9));
-        assertEquals(10, tuple.indexOf("2"));
-        assertEquals(11, tuple.indexOf(false));
-    }
-
-    @Test
-    void pop() {
-        Data tupleEmpty = new Tuple();
-        tupleEmpty.pop();
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        tuple.pop();
-        assertEquals(11, tuple.length());
-        tuple.pop();
-        assertEquals(10, tuple.length());
-        tuple.pop();
-        assertEquals(9, tuple.length());
-        tuple.pop();
-        assertEquals(8, tuple.length());
-        tuple.pop();
-        assertEquals(7, tuple.length());
-        tuple.pop();
-        assertEquals(6, tuple.length());
-    }
-
-    @Test
-    void remove() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false);
-        tuple.remove(0);
-        assertEquals("[1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false]", tuple.toString());
-        tuple.remove(tuple.length() - 1);
-        assertEquals("[1, 2, 3, 4, 5, 6, 7, 8, 9, 2]", tuple.toString());
-        assertFalse(tuple.contains(false));
-        assertThrows(IndexOutOfBoundsException.class, () -> tuple.remove(-1));
-        tuple.clear();
-        tuple.remove(0);
-    }
-
-    @Test
-    void clear() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.clear();
-        assertEquals(0, tuple.length());
-        tuple.clear();
-        assertEquals(0, tuple.length());
-    }
-
-    @Test
-    void testToString() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        assertEquals("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false]", tuple.toString());
-        tuple.clear();
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void reverse() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.reverse();
-        assertEquals( "[false, 2, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]",tuple.toString());
-        tuple.clear();
-        tuple.reverse();
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void slice() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.slice(1, 4);
-        assertEquals( "[1, 2, 3]",tuple.toString());
-        tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        tuple.slice(7, tuple.length());
-        assertEquals( "[7, 8, 9, 2, false]", tuple.toString());
-        tuple.clear();
-        tuple.slice(0, 1);
-        assertEquals("[]", tuple.toString());
-    }
-
-    @Test
-    void split() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2", null, false, null, null);
-        Tuple tuple2 = new Tuple();
-        tuple.split(7, tuple2);
-        assertEquals( "[0, 1, 2, 3, 4, 5, 6]", tuple.toString());
-        assertEquals( "[7, 8, 9, 2, false]", tuple2.toString());
-        tuple.clear();
-        tuple.split(1, tuple2);
-        assertEquals("[]", tuple.toString());
-        assertEquals("[]", tuple2.toString());
-    }
-
-    @Test
-    void join() {
-        Data tuple = new Tuple(0, 1, 2, 3, 4, 5, 6);
-        Data tuple2 = new Tuple(7, 8, 9, 2, null, false);
-        Data tuple3 = new Tuple(null, null, "ciao");
-        Data tuple4 = new Tuple();
-        tuple.join(tuple2, tuple3, tuple4);
-        assertEquals( "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false, ciao]", tuple.toString());
-        tuple3.clear();
-        tuple.join(tuple2, tuple3, tuple4);
-        assertEquals("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 2, false, ciao, 7, 8, 9, 2, false]", tuple.toString());
-    }
-
-    @Test
-    void fill() {
-        Tuple tuple = new Tuple();
-        tuple.fill(1, 10);
-        assertEquals( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-        tuple.fill(1, 10);
-        assertEquals( "[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-        tuple.fill(1, 0);
-        assertEquals("[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]", tuple.toString());
-    }
-
-    @Test
-    void isSubsetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "2");
-        Tuple tuple2 = new Tuple(0, 9, 2, 3, 7, 5, 6, 4, 8, 1, "2", null, null, null, false);
-        assertTrue(tuple.isSubsetOf(tuple2));
-        tuple.push("1");
-        assertFalse(tuple.isSubsetOf(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isSubsetOf(tuple2));
-    }
-
-    @Test
-    void isSupersetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, null, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 3, false, null, null, null, 2);
-        assertTrue(tuple.isSupersetOf(tuple2));
-        tuple2.pop();
-        tuple2.push("1");
-        assertFalse(tuple.isSupersetOf(tuple2));
-        tuple2.clear();
-        assertTrue(tuple.isSupersetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isSupersetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isSupersetOf("0"));
-        assertDoesNotThrow(() -> tuple.isSupersetOf(new Tuple()));
-    }
-
-    @Test
-    void isStrictSupersetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false);
-        assertTrue(tuple.isStrictSupersetOf(tuple2));
-        tuple2.pop();
-        tuple2.push("1");
-        assertFalse(tuple.isStrictSupersetOf(tuple2));
-        tuple2.clear();
-        assertTrue(tuple.isStrictSupersetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isStrictSupersetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isStrictSupersetOf("0"));
-        assertDoesNotThrow(() -> tuple.isStrictSupersetOf(new Tuple()));
-    }
-
-    @Test
-    void isStrictSubsetOf() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, false);
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, "cuai");
-        assertTrue(tuple.isStrictSubsetOf(tuple2));
-        tuple2.pop();
-        tuple.push("1");
-        assertFalse(tuple.isStrictSubsetOf(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isStrictSubsetOf(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isStrictSubsetOf(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isStrictSubsetOf("0"));
-        assertDoesNotThrow(() -> tuple.isStrictSubsetOf(new Tuple()));
-    }
-
-    @Test
-    void isDisjoint() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, null, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, null, false, null, null);
-        assertFalse(tuple.isDisjoint(tuple2));
-        tuple2.clear();
-        tuple2.push("-1");
-        assertTrue(tuple.isDisjoint(tuple2));
-        tuple.clear();
-        assertTrue(tuple.isDisjoint(tuple2));
-        assertThrows(NullPointerException.class, () -> tuple.isDisjoint(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.isDisjoint("0"));
-        assertDoesNotThrow(() -> tuple.isDisjoint(new Tuple()));
-    }
-
-    @Test
-    void symmetricDifference() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[4, 5, cuai]", tuple.symmetricDifference(tuple2).toString());
-        tuple2.push("-1");
-        assertEquals("[4, 5, cuai, -1]", tuple.symmetricDifference(tuple2).toString());
-        assertThrows(NullPointerException.class, () -> tuple.symmetricDifference(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.symmetricDifference("0"));
-        assertDoesNotThrow(() -> tuple.symmetricDifference(new Tuple()));
-    }
-
-    @Test
-    void subtract() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[4, 5, cuai]", tuple.subtract(tuple2).toString());
-        tuple2.push("-1");
-        assertEquals("[4, 5, cuai]", tuple.subtract(tuple2).toString());
-        assertThrows(NullPointerException.class, () -> tuple.subtract(null));
-        assertThrows(IllegalArgumentException.class, () -> tuple.subtract("0"));
-        assertDoesNotThrow(() -> tuple.subtract(new Tuple()));
-    }
-
-    @Test
-    void filter() {
-        Tuple tuple = new Tuple(0, 1, 2, 3, 4, 5, false, null, null, "cuai");
-        Tuple tuple2 = new Tuple(0, 1, 2, 3, false, null, null);
-        assertEquals("[0, 1, 2, 3, 4, 5]", tuple.filter(o -> o instanceof Integer).toString());
-        tuple2.push(-1);
-        assertEquals("[-1]", tuple2.filter(o -> o instanceof Integer && (int) o < 0).toString());
-    }
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/BCMLDocument.java
===================================================================
diff --git a/src/main/java/ch/mazluc/BCMLDocument.java b/src/main/java/ch/mazluc/BCMLDocument.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/BCMLDocument.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,191 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.List;
-import java.util.NoSuchElementException;
-import java.util.logging.Level;
-import java.util.logging.LogRecord;
-import java.util.logging.Logger;
-
-/**
- * Represents a document of type BCML.
- * A document is made of lines.
- * A line is made of a key and a value.
- *
- * @param <K> key type
- * @author Luca Mazza
- * @version 1.0
- * @since 1.0
- */
-public class BCMLDocument<K> implements Document<K>{
-
-    /**
-     * The array of lines.
-     */
-    private final transient List<Line<K>> lines;
-
-    private static final Logger logger = Logger.getLogger(BCMLDocument.class.getName());
-
-    public BCMLDocument() {
-        this.lines = new ArrayList<>();
-    }
-
-    public BCMLDocument(File file){
-        this();
-        this.deserialize(file);
-    }
-
-    /**
-     * Retrieves the count of lines of the Document.
-     *
-     * @return the count of lines
-     */
-    @Override
-    public int lineCount() {
-        return this.lines.size();
-    }
-
-    /**
-     * Checks if the Document is empty or not.
-     *
-     * @return true if the Document is empty, false otherwise
-     */
-    @Override
-    public boolean isEmpty() {
-        return lines.isEmpty();
-    }
-
-    /**
-     * Retrieves the line at the specified index.
-     *
-     * @param index the index
-     * @return the line
-     * @throws IndexOutOfBoundsException if the index is out of bounds
-     */
-    @Override
-    public Line<K> getLine(int index) throws IndexOutOfBoundsException {
-        if (this.isEmpty()) { throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length 0"); }
-        return this.lines.get(index);
-    }
-
-    /**
-     * Appends a line at the end of the document.
-     *
-     * @param line the line
-     */
-    @Override
-    public void append(Line<K> line) {
-        this.lines.add(line);
-    }
-
-    /**
-     * Empties the Document
-     */
-    @Override
-    public void clear() {
-        this.lines.clear();
-    }
-
-    private void toBCML(String doc) {
-        for (String line : doc.split("\n")) {
-            this.append(Line.parseLine(line));
-        }
-    }
-
-    /**
-     * Serializes the document to the given file.
-     *
-     * @param  file  the file to be serialized in
-     */
-    public void serialize(File file) {
-        try (BufferedWriter writer = new BufferedWriter(new java.io.FileWriter(file))) {
-            for (Line<K> line : this) {
-                writer.append(line.toString());
-            }
-            writer.flush();
-            logger.log(new LogRecord(Level.INFO, "Document serialized to " + file.getAbsolutePath()));
-        } catch (Exception e) {
-            logger.warning(e.getMessage());
-        }
-    }
-
-    /**
-     * Deserializes the document in the given file.
-     *
-     * @param  file  the file in which the document is contained
-     */
-    private void deserialize(File file) {
-        try(BufferedReader reader = new BufferedReader(new java.io.FileReader(file))) {
-            if (reader.lines().findAny().isEmpty()) {
-                logger.log(
-                        new LogRecord(
-                                Level.WARNING,
-                                "Document is empty, can't deserialize from " + file.getAbsolutePath()
-                        )
-                );
-                return;
-            }
-            StringBuilder doc = new StringBuilder();
-            String line;
-            while ((line = reader.readLine()) != null) {
-                line = line.trim();
-                if (line.isEmpty() || line.charAt(0) == '#') { continue; }
-                doc.append(line).append("\n");
-            }
-            logger.log(new LogRecord(Level.INFO, "Document deserialized from " + file.getAbsolutePath()));
-        } catch (Exception e) {
-            logger.warning(e.getMessage());
-        }
-    }
-
-    /**
-     * Returns an iterator over elements of type {@code T}.
-     *
-     * @return an Iterator.
-     */
-    @Override
-    public Iterator<Line<K>> iterator() {
-        return new Iterator<>() {
-            private int currentIndex = 0;
-
-            @Override
-            public boolean hasNext() {
-                return currentIndex < lineCount() && lines.get(currentIndex) != null;
-            }
-
-            @Override
-            public Line<K> next() throws NoSuchElementException {
-                if (!hasNext()) {
-                    throw new NoSuchElementException();
-                }
-                return lines.get(currentIndex++);
-            }
-        };
-    }
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/Line.java
===================================================================
diff --git a/src/main/java/ch/mazluc/Line.java b/src/main/java/ch/mazluc/Line.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/Line.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,155 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import java.lang.reflect.Array;
-import java.util.Arrays;
-import java.util.Objects;
-
-/**
- * Represents a line.
- * A line is made of a key and a value.
- *
- * @param key key
- * @param value value
- * @param <K> key type
- */
-public record Line<K>(K key, Object value) {
-    /**
-     * Constructor for the line
-     *
-     * @param key the key
-     * @param value the value
-     */
-    public Line {
-        Objects.requireNonNull(key);
-        Objects.requireNonNull(value);
-    }
-
-    /**
-     * Constructor for the empty line
-     *
-     * @param key the key
-     */
-    public Line(K key) {
-        this(key, null);
-    }
-
-    /**
-     * Returns the string representation of the line
-     *
-     * @return the string representation
-     */
-    @Override
-    public String toString() {
-        String result = (
-                key.getClass() == String.class ?
-                        "\"" + this.key + "\"" :
-                        this.key.toString());
-
-        if (this.value != null && this.value.getClass().isArray()) {
-            if (this.value instanceof Object[] objects) {
-                return result + ": " + Arrays.deepToString(objects);
-            }
-            int length = Array.getLength(this.value);
-            Object[] array = new Object[length];
-            for (int i = 0; i < length; i++) {
-                array[i] = Array.get(this.value, i);
-            }
-            return result + ": " + Arrays.deepToString(array);
-        }
-
-        if (this.value != null && this.value instanceof String string) {
-            return result + ": " + "\""+ string + "\"";
-        }
-
-        if (this.value != null && this.value instanceof Line<?> line) {
-            String nestedLine = line.toString().replace("\n", "\n\t");
-            return result + ": {\n\t" + nestedLine + "\n}";
-        }
-
-        return result + ": " + this.value;
-    }
-
-    /**
-     * Returns the key type of the line.
-     *
-     * @return the key type
-     */
-    public Class<?> keyType() {
-        return key.getClass();
-    }
-
-    /**
-     * Parses a line from a string.
-     *
-     * @param s the string
-     * @return the line
-     * @throws ClassCastException if the line is invalid
-     */
-    @SuppressWarnings("unchecked")
-    public static <K> Line<K> parseLine(String s) throws ClassCastException {
-        s = StringTool.trimAll(s);
-        String[] splitted = s.split(":");
-        K key = null;
-        if (splitted.length == 2){
-            try {
-                key = (K) StringTool.parseString(splitted[0]);
-            } catch (ClassCastException ignored) {
-                throw new ClassCastException("Invalid key type: " + splitted[0]);
-            }
-            if (splitted[1].startsWith("[") && splitted[1].endsWith("]")) {
-                Object[] value = StringTool.toArray(splitted[1]);
-                return new Line<>(key, value);
-            }
-            Object value = StringTool.parseString(splitted[1]);
-            return new Line<>(key, value);
-        }
-        try {
-            return new Line<>(
-                    (K) StringTool.parseString(splitted[0]),
-                    parseLine(s.substring(splitted[0].length() + 1))
-            );
-        } catch (ClassCastException ignored) {
-            throw new ClassCastException("Invalid key type: " + splitted[0]);
-        }
-    }
-
-    /**
-     * Returns the subline at the specified depth
-     *
-     * @param depth the depth
-     * @return the subline
-     */
-    @SuppressWarnings("unchecked")
-    public Line<K> subLine(int depth) {
-        if (depth == 0) {
-            return this;
-        }
-        try {
-            return ((Line<K>) this.value()).subLine(depth - 1);
-        } catch (ClassCastException ignored) {
-            return this;
-        }
-    }
-}
Index: src/main/java/ch/mazluc/StringTool.java
===================================================================
diff --git a/src/main/java/ch/mazluc/StringTool.java b/src/main/java/ch/mazluc/StringTool.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/StringTool.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,78 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-public class StringTool {
-
-    private StringTool(){
-        // utility
-    }
-
-    public static String join(String separator, String... strings) {
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < strings.length; i++) {
-            sb.append(strings[i]);
-            if (i < strings.length - 1) {
-                sb.append(separator);
-            }
-        }
-        return sb.toString();
-    }
-
-    public static String trimAll(String string) {
-        return string.replaceAll("\\s|\\{|\\}|\"", "");
-    }
-
-    public static Object[] toArray(String s) {
-        s = s.replaceAll("\\[|\\]", "");
-        String[] splitted = s.split(",");
-        Object[] result = new Object[splitted.length];
-        for (int i = 0; i < splitted.length; i++) {
-            result[i] = parseString(splitted[i]);
-        }
-        return result;
-    }
-
-    public static Object parseString(String s) {
-        s = trimAll(s);
-        if (s.isEmpty()) {
-            return null;
-        }
-
-        try {
-            return Integer.parseInt(s);
-        } catch (NumberFormatException e1) {
-            try {
-                return Double.parseDouble(s);
-            } catch (NumberFormatException e2) {
-                if (s.equalsIgnoreCase("true") || s.equalsIgnoreCase("false")) {
-                    return Boolean.parseBoolean(s);
-                } else if (s.length() == 1) {
-                    return s.charAt(0);
-                } else {
-                    return s;
-                }
-            }
-        }
-    }
-}
Index: src/test/java/ch/mazluc/TableTest.java
===================================================================
diff --git a/src/test/java/ch/mazluc/TableTest.java b/src/test/java/ch/mazluc/TableTest.java
deleted file mode 100644
--- a/src/test/java/ch/mazluc/TableTest.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,350 +0,0 @@
-package ch.mazluc;
-
-import org.junit.jupiter.api.Test;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-class TableTest {
-
-    @Test
-    void length() {
-        Table table = new Table();
-        assertEquals(0, table.length());
-        table.push(new Tuple(0, 1, 2));
-        assertEquals(1, table.length());
-        table.push(new Tuple(3, 4, 5));
-        assertEquals(2, table.length());
-    }
-
-    @Test
-    void isEmpty() {
-        Table table = new Table();
-        assertTrue(table.isEmpty());
-        table.push(new Tuple(0, 1, 2));
-        table.push(new Tuple(3, 4, 5));
-        assertFalse(table.isEmpty());
-    }
-
-    @Test
-    void contains() {
-        Table table = new Table();
-        table.push(new Tuple(0, 1, 2));
-        table.push(new Tuple(3, 4, 5));
-        assertTrue(table.contains(0));
-        assertFalse(table.contains(6));
-        assertTrue(table.contains(2));
-        table.clear();
-        assertFalse(table.contains(0));
-    }
-
-    @Test
-    void setValues() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1), 1, 2, new Tuple(3, 4, 5, 6), 4);
-        assertEquals(5, table.length());
-        assertEquals(0, (int)table.getValue(0, 0));
-        assertEquals(1, (int)table.getValue(1,0));
-        assertEquals(2, (int)table.getValue(2,0));
-        assertEquals(6, (int)table.getValue(3,3));
-        assertEquals(4, (int)table.getValue(4,0));
-    }
-
-    @Test
-    void push() {
-        Table table = new Table();
-        table.push(1);
-        table.push(new Tuple(2, 3));
-        table.push(3);
-        assertFalse(table.isEmpty());
-        assertTrue(table.contains(1));
-        assertTrue(table.contains(2));
-        assertTrue(table.contains(3));
-        assertEquals(3, table.length());
-        assertEquals(1, (int)table.getValue(0,0));
-        assertEquals(2, (int)table.getValue(1,0));
-        assertEquals(3, (int)table.getValue(2,0));
-    }
-
-    @Test
-    void insert() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(6.5e13, 1, false),
-                new Tuple(1, 'e', 3),
-                new Tuple(3, 4.4, 5)
-        );
-        table.insert(0, 0, 6);
-        table.insert(1, 1, 7);
-        table.insert(2, 2, 8);
-        assertTrue(table.contains(6));
-        assertTrue(table.contains(7));
-        assertTrue(table.contains(8));
-        assertEquals(3, table.length());
-        assertEquals(6, (int)table.getValue(0,0));
-        assertEquals(7, (int)table.getValue(1,1));
-        assertEquals(8, (int)table.getValue(2,2));
-    }
-
-    @Test
-    void replace() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, "1", false),
-                new Tuple(1, 3.3, 3),
-                new Tuple(3, 4f, 5)
-        );
-        table.replace(0, 0, 6);
-        table.replace(1, 1, 7);
-        table.replace(2, 2, 8);
-        assertTrue(table.contains(6));
-        assertTrue(table.contains(7));
-        assertTrue(table.contains(8));
-        assertEquals(3, table.length());
-        assertEquals(6, (int)table.getValue(0,0));
-        assertEquals(7, (int)table.getValue(1,1));
-        assertEquals(8, (int)table.getValue(2,2));
-    }
-
-    @Test
-    void swap() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.swap(0, 1);
-        table.swap(1, 2);
-        assertEquals(3, (int)table.getValue(0,0));
-        assertEquals(0, (int)table.getValue(2,0));
-        assertFalse((boolean) table.getValue(1, 4));
-        assertNotEquals(2, (int)table.getValue(0,0));
-        assertNotEquals(1, (int)table.getValue(1,0));
-    }
-
-    @Test
-    void getValue() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(3, (int)table.getValue(1,0));
-        assertEquals(7, (int)table.getValue(2,0));
-        assertEquals(2, (int)table.getValue(0,2));
-        assertEquals("2", table.getValue(2,3));
-    }
-
-    @Test
-    void indexOf() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertArrayEquals(new int[]{0, 0}, table.indexOf(0));
-        assertArrayEquals(new int[]{0, 1}, table.indexOf(1));
-        assertArrayEquals(new int[]{0, 2}, table.indexOf(2));
-        assertArrayEquals(new int[]{1, 0}, table.indexOf(3));
-        assertArrayEquals(new int[]{1, 1}, table.indexOf(4));
-        assertArrayEquals(new int[]{1, 2}, table.indexOf(5));
-        assertArrayEquals(new int[]{1, 3}, table.indexOf(6));
-        assertArrayEquals(new int[]{2, 0}, table.indexOf(7));
-        assertArrayEquals(new int[]{2, 1}, table.indexOf(8));
-        assertArrayEquals(new int[]{2, 2}, table.indexOf(9));
-        assertArrayEquals(new int[]{2, 3}, table.indexOf("2"));
-        assertArrayEquals(new int[]{2, 4}, table.indexOf(false));
-    }
-
-    @Test
-    void pop() {
-        Table table = new Table(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.pop();
-        assertEquals(2, table.length());
-        table.pop();
-        assertEquals(1, table.length());
-        table.pop();
-        assertEquals(0, table.length());
-        table.pop();
-        assertEquals(0, table.length());
-    }
-
-    @Test
-    void remove() {
-        Table table = new Table(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.remove(0, 0);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(0));
-        table.remove(1, 1);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(4));
-        table.remove(2, 2);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(9));
-        table.remove(0, 0);
-        assertEquals(3, table.length());
-        assertFalse(table.contains(0));
-    }
-
-    @Test
-    void clear() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.clear();
-        assertEquals(0, table.length());
-        assertFalse(table.contains(5));
-        assertFalse(table.contains(6));
-        assertFalse(table.contains(7));
-        assertFalse(table.contains(8));
-        assertFalse(table.contains(9));
-    }
-
-    @Test
-    void slice() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        table.slice(0, 2);
-        assertEquals(2, table.length());
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(6, (int)table.getValue(1,3));
-        table.slice(1, 2);
-        assertEquals(1 , table.length());
-        assertEquals(4, (int)table.getValue(0, 1));
-
-    }
-
-    @Test
-    void join() {
-        Table table = new Table();
-        Table table1 = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6));
-        table1.setValues(new Tuple(7, 8, 9, "2", false), new Tuple(true, 'a'));
-        table.join(table1);
-        assertEquals(4, table.length());
-        assertEquals(0, (int)table.getValue(0,0));
-        assertEquals(1, (int)table.getValue(0,1));
-        assertEquals(2, (int)table.getValue(0,2));
-        assertEquals(3, (int)table.getValue(1,0));
-        assertEquals(4, (int)table.getValue(1,1));
-        assertEquals(5, (int)table.getValue(1,2));
-        assertEquals(6, (int)table.getValue(1,3));
-        assertEquals(7, (int)table.getValue(2,0));
-        assertEquals(8, (int)table.getValue(2,1));
-        assertEquals(9, (int)table.getValue(2,2));
-        assertEquals("2", table.getValue(2,3));
-        assertEquals(false, table.getValue(2,4));
-        assertEquals(true, table.getValue(3,0));
-        assertEquals('a', (char)table.getValue(3,1));
-    }
-
-    @Test
-    void isSubsetOf() {
-        Table table = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6));
-        Table table1 = new Table();
-        table1.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9, "2"));
-        assertTrue(table.isSubsetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9, "2"));
-        assertTrue(table.isSubsetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2));
-        assertFalse(table.isSubsetOf(table1));
-    }
-
-    @Test
-    void isSupersetOf() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        Table table1 = new Table();
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertTrue(table.isSupersetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true)
-        );
-        assertFalse(table.isSupersetOf(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true),
-                new Tuple(13, 14, 15, "4", false)
-        );
-        assertFalse(table.isSupersetOf(table1));
-    }
-
-    @Test
-    void subtract() {
-        Table table = new Table();
-        Table table1 = new Table();
-        table.setValues(new Tuple(0, 1, 2), new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9));
-        table1.setValues(new Tuple(0, 1, 2));
-        Table comp = new Table(new Tuple(3, 4, 5, 6), new Tuple(7, 8, 9));
-        Table subt = (Table) table.subtract(table1);
-        assertEquals(comp, subt);
-    }
-
-    @Test
-    void filter() {
-        Table table = new Table();
-        table.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3.0, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertEquals("[2]", table.filter(t -> t instanceof String).toString());
-        assertEquals("[0, 1, 2, 4, 5, 6, 7, 8, 9]", table.filter(t -> t instanceof Integer).toString());
-        assertEquals("[3.0]", table.filter(t -> t instanceof Double).toString());
-        assertEquals("[0, 1, 2, 3.0, 4, 5, 6, 7, 8, 9]", table.filter(t -> t instanceof Number).toString());
-    }
-
-    @Test
-    void isDisjoint() {
-        Table table = new Table();
-        table.setValues(new Tuple("ciao", true), new Tuple(0.2, 4.4f));
-        Table table1 = new Table();
-        table1.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false)
-        );
-        assertTrue(table.isDisjoint(table1));
-        table1.setValues(
-                new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", true)
-        );
-        assertFalse(table.isDisjoint(table1));
-        table1.setValues(new Tuple(0, 1, 2),
-                new Tuple(3, 4, 5, 6),
-                new Tuple(7, 8, 9, "2", false),
-                new Tuple(10, 11, 12, "3", false)
-        );
-        assertTrue(table.isDisjoint(table1));
-    }
-}
\ No newline at end of file
Index: src/main/java/ch/mazluc/Document.java
===================================================================
diff --git a/src/main/java/ch/mazluc/Document.java b/src/main/java/ch/mazluc/Document.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/Document.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,73 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import java.io.Serializable;
-import java.lang.reflect.Type;
-
-/**
- * Interface for Document.
- * A Document is a collection of lines.
- *
- * @param <K>
- * @author Luca Mazza
- * @version 1.0
- * @since 1.0
- */
-public interface Document<K> extends Iterable<Line<K>>, Serializable {
-
-    /**
-     * Retrieves the count of lines of the Document.
-     *
-     * @return the count of lines
-     */
-    int lineCount();
-
-    /**
-     * Checks if the Document is empty or not.
-     *
-     * @return true if the Document is empty, false otherwise
-     */
-    boolean isEmpty();
-
-
-    /**
-     * Retrieves the line at the specified index.
-     *
-     * @param index the index
-     * @return the line
-     */
-    Line<K> getLine(int index);
-
-    /**
-     * Appends a line at the end of the document.
-     *
-     * @param line the line
-     */
-    void append(Line<K> line);
-
-    /**
-     * Empties the Document
-     */
-    void clear();
-}
Index: src/main/java/ch/mazluc/Tuple.java
===================================================================
diff --git a/src/main/java/ch/mazluc/Tuple.java b/src/main/java/ch/mazluc/Tuple.java
deleted file mode 100644
--- a/src/main/java/ch/mazluc/Tuple.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,738 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-import java.util.Random;
-import java.util.function.Predicate;
-import java.util.stream.IntStream;
-
-import static java.lang.System.arraycopy;
-
-/**
- * This class represents a tuple of values
- *
- * @author Luca Mazza
- * @version 1.0
- * @since 1.0
- */
-public class Tuple implements Data {
-
-    private static final String OINAT = "Object is not a tuple";
-
-    private static final Random random = new Random();
-    /**
-     * The values of the tuple
-     *
-     * @since 1.0
-     */
-    private Object[] values;
-
-    /**
-     * Creates a new instance of tuple.Tuple
-     *
-     * @since 1.0
-     */
-    public Tuple() {
-        this.values = new Object[0];
-    }
-
-    /**
-     * Creates a new instance of tuple.Tuple
-     * Defines the values of the tuple
-     *
-     * @param values the values of the tuple
-     * @since 1.0
-     */
-    public Tuple(Object... values) {
-        if (values.length == 0) {
-            this.values = new Object[0];
-            return;
-        }
-        this.values = new Object[values.length];
-        arraycopy(values, 0, this.values, 0, values.length);
-        this.clearNulls();
-    }
-
-    /**
-     * Determines if the given object is an instance of Tuple.
-     *
-     * @param obj the object to be checked
-     * @return  true if the object is an instance of Tuple, false otherwise
-     */
-    static boolean isTuple(Object obj) {
-        return obj.getClass() == Tuple.class;
-    }
-
-    /**
-     * Returns the length of the tuple
-     *
-     * @return the length of the tuple
-     * @since 1.0
-     */
-    @Override
-    public int length() {
-        return this.values.length;
-    }
-
-    /**
-     * Returns if the tuple is empty
-     *
-     * @return if the tuple is empty
-     * @since 1.0
-     */
-    @Override
-    public boolean isEmpty(){
-        return this.values.length == 0;
-    }
-
-    /**
-     * Returns if the tuple is equal to another
-     *
-     * @param obj the tuple to compare
-     * @return if the tuple is equal to another
-     * @since 1.0
-     */
-    @Override
-    public boolean equals(Object obj) {
-        if (obj != null && !isTuple(obj)) {
-            return false;
-        }
-        Tuple tuple = (Tuple) obj;
-        assert tuple != null;
-        if(this.values.length != tuple.values.length){
-            return false;
-        }
-        for (int i = 0; i < this.values.length; i++) {
-            if (this.values[i] != tuple.values[i]){
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Determines whether the given value is contained within the collection.
-     *
-     * @param value the value to check for containment
-     * @return true if the value is contained, false otherwise
-     * @since 1.0
-     */
-    @Override
-    public <T> boolean contains(T value) {
-        return this.indexOf(value) != -1;
-    }
-
-    /**
-     * Returns if the tuple contains a value of the specified type
-     *
-     * @param type the type of the value
-     * @return if the tuple contains a value of the specified type
-     * @since 1.0
-     */
-    public boolean containsType(Class<?> type) {
-        for (Object value : this.values) {
-            if (value == null) {
-                return false;
-            }
-            if (value.getClass() == type) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Replaces the values of the tuple
-     *
-     * @param values the new values of the tuple
-     * @since 1.0
-     */
-    public void setValues(Object... values){
-        if (values.length == 0) {
-            this.values = new Object[0];
-            return;
-        }
-        this.values = values;
-        this.clearNulls();
-    }
-
-    /**
-     * Appends a value of T type to the tuple
-     *
-     * @param <T> value the value to append
-     * @since 1.0
-     */
-    @Override
-    public <T> void push(T value) {
-        if (value == null) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length + 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length);
-        newValues[this.values.length] = value;
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Inserts a new value at the specified index
-     *
-     * @param index index to insert the value into
-     * @param value value to insert
-     * @since 1.0
-     */
-    public <T> void insert(int index, T value) throws IndexOutOfBoundsException {
-        if (value == null) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length + 1];
-        arraycopy(this.values, 0, newValues, 0, index);
-        newValues[index] = value;
-        arraycopy(this.values, index, newValues, index + 1, this.values.length - index);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Replaces the value at the specified index
-     *
-     * @param index the index of the value
-     * @param value the new value
-     * @since 1.0
-     */
-    public <T> void replace(int index, T value) throws IndexOutOfBoundsException {
-        if (value == null) {
-            return;
-        }
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length " + this.values.length);
-        }
-        this.values[index] = value;
-        this.clearNulls();
-    }
-
-    /**
-     * Swaps the elements at the specified indices in the array.
-     *
-     * @param index1 the index of the first element to be swapped
-     * @param index2 the index of the second element to be swapped
-     * @since 1.0
-     */
-    @Override
-    public void swap(int index1, int index2) throws IndexOutOfBoundsException {
-        if (index1 < 0 || index2 < 0 || index1 >= this.values.length || index2 >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index out of bounds for length " + this.values.length);
-        }
-        Object temp = this.values[index1];
-        this.values[index1] = this.values[index2];
-        this.values[index2] = temp;
-    }
-
-    /**
-     * Returns the value at the specified index of the tuple
-     * Value is already typed, but be careful, put your values
-     * in a rightful type variable
-     *
-     * @param index the index of the value
-     * @return the value at the specified index
-     * @since 1.0
-     */
-    @SuppressWarnings("unchecked")
-    public <T> T getValue(int index) throws IndexOutOfBoundsException {
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException("Index " + index + " out of bounds for length " + this.values.length);
-        }
-        return (T) this.values[index];
-    }
-
-    /**
-     * Returns a new tuple with only the values of the specified type
-     *
-     * @param type the type of the values (to pass as `Class.class`, for example `Integer.class`)
-     * @return a new tuple with only the values of the specified type
-     * @since 1.0
-     */
-    public Tuple getValuesOfType(Class<?> type) {
-        Tuple tuple = new Tuple();
-        if (!containsType(type)) {
-            return tuple;
-        }
-        Tuple copy = new Tuple(this.values); // Create a copy of the original tuple
-        for (int i = 0; i < copy.length(); i++) {
-            if (copy.getValue(i) == null) {
-                copy.remove(i);
-            }
-        }
-        for (Object value : copy) {
-            if (value.getClass() == type) {
-                tuple.push(value);
-            }
-        }
-        return tuple;
-    }
-
-    /**
-     * Returns the index of a specified value
-     *
-     * @param value the value to search
-     * @return the index of the value
-     * @since 1.0
-     */
-    public <T> int indexOf(T value) {
-        for (int i = 0; i < this.values.length; i++) {
-            if (value instanceof String && this.values[i].equals(value.toString())) {
-                return i;
-            }
-            if (value instanceof Tuple && this.values[i].equals(value)) {
-                return i;
-            }
-            if (this.values[i] != null && this.values[i].equals(value)) {
-                return i;
-            }
-            if (this.values[i] == value) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    /**
-     * Removes the last value of the tuple
-     */
-    @Override
-    public void pop() {
-        if (this.values.length == 0) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, this.values.length - 1);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Removes the element at the specified index from the array of values.
-     *
-     * @param index the index of the element to be removed
-     * @since 1.0
-     */
-    public void remove(int index) throws IndexOutOfBoundsException {
-        if (this.values.length == 0) {
-            return;
-        }
-        if (index < 0 || index >= this.values.length) {
-            throw new IndexOutOfBoundsException();
-        }
-        Object[] newValues = new Object[this.values.length - 1];
-        arraycopy(this.values, 0, newValues, 0, index);
-        if (this.values.length - 1 - index >= 0)
-            arraycopy(this.values, index + 1, newValues, index, this.values.length - 1 - index);
-        this.values = newValues;
-        this.clearNulls();
-    }
-
-    /**
-     * Clears the tuple, making it of length 0
-     *
-     * @since 1.0
-     */
-    @Override
-    public void clear() {
-        this.values = new Object[0];
-    }
-
-    /**
-     * Clears T null values from the array.
-     */
-    private void clearNulls() {
-        if (this.values.length == 0) {
-            return;
-        }
-        for (int i = 0; i < this.values.length; i++) {
-            if (this.values[i] == null) {
-                this.remove(i);
-            }
-        }
-    }
-
-    /**
-     * Returns the string representation of the tuple
-     *
-     * @return the string representation of the tuple
-     * @since 1.0
-     */
-    @Override
-    public String toString() {
-        if (this.values.length == 0) {
-            return "[]";
-        }
-        return Arrays.toString(this.values);
-    }
-
-    /**
-     * Returns the hash code of the tuple
-     *
-     * @return the hash code of the tuple
-     * @since 1.0
-     */
-    @Override
-    public int hashCode() {
-        if (this.values.length == 0) {
-            return 0;
-        }
-        return Arrays.hashCode(this.values);
-    }
-
-    /**
-     * Reverses the tuple
-     *
-     * @since 1.0
-     */
-    public void reverse() {
-        if (this.values.length == 0 || this.values.length == 1) {
-            return;
-        }
-        Object[] newValues = new Object[this.values.length];
-        for (int i = 0; i < this.values.length; i++) {
-            newValues[i] = this.values[this.values.length - i - 1];
-        }
-        this.setValues(newValues);
-    }
-
-    /**
-     * Slices the tuple from a defined start to a defined end
-     *
-     * @param start the first index
-     * @param end   the last index
-     * @since 1.0
-     */
-    @Override
-    public void slice(int start, int end) {
-        if (end > this.values.length) {
-            end = this.values.length;
-        }
-        if (start < 0) {
-            start = 0;
-        }
-        Object[] newValues = new Object[end - start];
-        arraycopy(this.values, start, newValues, 0, newValues.length);
-        this.setValues(newValues);
-    }
-
-    /**
-     * Splits the tuple at the specified index
-     * The new tuple has the same length as the old one
-     *
-     * @param index the index to split
-     * @param data the new tuple
-     * @since 1.0
-     */
-    public void split(int index, Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (index > this.values.length) {
-            index = this.values.length;
-        }
-        if (index < 0) {
-            index = 0;
-        }
-        Tuple tmp = (Tuple) data;
-        Object[] newValues = new Object[index];
-        Object[] newValues2 = new Object[this.values.length - index];
-        arraycopy(this.values, index, newValues2, 0, this.values.length - index);
-        tmp.setValues(newValues2);
-        arraycopy(this.values, 0, newValues, 0, index);
-        this.setValues(newValues);
-    }
-
-    /**
-     * Joins two tuples into one
-     *
-     * @param datas the tuples to join
-     * @since 1.0
-     */
-    @Override
-    public void join(Object... datas) {
-        for (Object data : datas) {
-            if (!isTuple(data)) {
-                continue;
-            }
-            Tuple tmp = (Tuple) data;
-            for (int i = 0; i < tmp.length(); i++) {
-                this.push(tmp.getValue(i));
-            }
-        }
-    }
-
-    /**
-     * Fills the array with the specified value.
-     *
-     * @param value the value to fill the array with
-     */
-    public <T> void fill(T value, int amount) {
-        if (amount < 0) { amount = 0; }
-        if (amount == 0 || value == null) { return; }
-        for (int i = 0; i < amount; i++) {
-            this.push(value);
-        }
-    }
-
-    /**
-     * Fills the array with random values.
-     *
-     * @param amount the amount of random values to generate
-     */
-    public void fillRandom(int amount) {
-        if (amount < 0 || amount > this.values.length) {
-            amount = 0;
-        }
-        if (amount == 0) {
-            return;
-        }
-        for (int i = 0; i < amount; i++) {
-            this.values[i] = random.nextInt(100);
-        }
-    }
-
-    /**
-     * Fills the values array with random integers between 0 and 99 (inclusive).
-     */
-    public void fillRandom(int min, int max, int amount) {
-        if (amount < 0 || amount > this.values.length) {
-            amount = 0;
-        }
-        if (amount == 0) {
-            return;
-        }
-        if (min > max) {
-            int tmp = min;
-            min = max;
-            max = tmp;
-        }
-        for (int i = 0; i < amount; i++) {
-
-            this.values[i] = random.nextInt(max - min + 1) + min;
-        }
-    }
-
-    /**
-     * Determines if this tuple is a subset of the given tuple.
-     *
-     * @param data the tuple to check against
-     * @return true if this tuple is a subset of the given tuple, false otherwise
-     */
-    @Override
-    public boolean isSubsetOf(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (this.length() > ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < this.length(); i++) {
-            if (!tmp.contains(this.getValue(i))) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Determines if this tuple is a superset of the given tuple.
-     *
-     * @param data the tuple to check against
-     * @return true if this tuple is a superset of the given tuple, false otherwise
-     */
-    @Override
-    public boolean isSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (this.length() < ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        return tmp.isSubsetOf(this);
-    }
-
-    /**
-     * Determines if this set is a strict superset of the given tuple.
-     * A strict superset means that this set contains all the values
-     * of the given tuple in the same order
-     *
-     * @param data the tuple to compare against
-     * @return true if this set is a strict superset of the given tuple, false otherwise
-     */
-    public boolean isStrictSupersetOf(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (this.length() < ((Tuple) data).length()) {
-            return false;
-        }
-        int consecutive = 0;
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < tmp.length(); i++) {
-            if (this.contains(tmp.getValue(i))) {
-                consecutive++;
-            } else {
-                consecutive = 0;
-            }
-        }
-        return consecutive == tmp.length();
-    }
-
-    /**
-     * Determines if this set is a strict subset of the given tuple.
-     * A strict subset means that this set contains all the values
-     * of the given tuple in the same order
-     *
-     * @param data the tuple to compare against
-     * @return true if this set is a strict subset of the given tuple, false otherwise
-     */
-    public boolean isStrictSubsetOf(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (this.length() > ((Tuple) data).length()) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        int consecutive = 0;
-        for (int i = 0; i < this.length(); i++) {
-            if (tmp.contains(this.getValue(i))){
-                consecutive++;
-            } else {
-                consecutive = 0;
-            }
-        }
-        return consecutive == this.length();
-    }
-
-    /**
-     * Checks if the current tuple.Tuple is disjoint with the given tuple.Tuple.
-     *
-     * @param data the tuple.Tuple to check for disjointness
-     * @return true if the Tuples are disjoint, false otherwise
-     */
-    @Override
-    public boolean isDisjoint(Object data) throws IllegalArgumentException{
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        if (data.equals(this)) {
-            return false;
-        }
-        Tuple tmp = (Tuple) data;
-        for (int i = 0; i < tmp.length(); i++) {
-            if (this.contains(tmp.getValue(i))){
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Returns the symmetric difference between this tuple and the given tuple
-     * The symmetric difference is the set of values that are in either tuple
-     * but not in both
-     *
-     * @param data the tuple
-     * @return the symmetric difference
-     */
-    public Object symmetricDifference(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        Tuple tuple = (Tuple) data;
-        Tuple result = new Tuple();
-        for (int i = 0; i < this.length(); i++) {
-            if (!tuple.contains(this.getValue(i))) {
-                result.push(this.getValue(i));
-            }
-        }
-        for (int i = 0; i < tuple.length(); i++) {
-            if (!this.contains(tuple.getValue(i))) {
-                result.push(tuple.getValue(i));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Subtracts the given tuple from this tuple
-     *
-     * @param data the tuple
-     * @return the result
-     */
-    @Override
-    public Object subtract(Object data) throws IllegalArgumentException {
-        if (!isTuple(data)){ throw new IllegalArgumentException(OINAT); }
-        Tuple tmp = (Tuple) data;
-        Tuple result = new Tuple();
-        for (int i = 0; i < this.length(); i++) {
-            if (!tmp.contains(this.getValue(i))){
-                result.push(this.getValue(i));
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Filters the elements of the tuple.Tuple based on the given predicate.
-     *
-     * @param predicate the predicate used to filter the elements of the tuple.Tuple
-     * @return the filtered tuple.Tuple
-     */
-    @Override
-    public Object filter(Predicate<Object> predicate){
-        Tuple result = new Tuple();
-        IntStream.range(
-                0,
-                this.length()
-        )
-        .filter(
-            i -> predicate.test(this.getValue(i))
-        ).mapToObj(
-                this::getValue
-        ).forEachOrdered(result::push);
-
-        return result;
-    }
-
-    /**
-     * Returns an iterator over elements of type {@code T}.
-     *
-     * @return an Iterator.
-     * @since 1.0
-     */
-    @Override
-    public Iterator<Object> iterator() {
-        return new Iterator<>() {
-            private int currentIndex = 0;
-
-            @Override
-            public boolean hasNext() {
-                return currentIndex < length() && values[currentIndex] != null;
-            }
-
-            @Override
-            public Object next() {
-                if (!hasNext()) { throw new NoSuchElementException(); }
-                return values[currentIndex++];
-            }
-        };
-    }
-
-}
\ No newline at end of file
Index: src/test/java/ch/mazluc/BCMLDocumentTest.java
===================================================================
diff --git a/src/test/java/ch/mazluc/BCMLDocumentTest.java b/src/test/java/ch/mazluc/BCMLDocumentTest.java
deleted file mode 100644
--- a/src/test/java/ch/mazluc/BCMLDocumentTest.java	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
+++ /dev/null	(revision c94ef23ebc6861585fb6841613bde92c8c39acb6)
@@ -1,66 +0,0 @@
-/*
- * MIT License
- *
- * Copyright (c) 2023 Luca Mazza
- * Permission is hereby granted, free of charge, to any person obtaining a copy
- * of this software and associated documentation files (the "Software"), to deal
- * in the Software without restriction, including without limitation the rights
- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
- * copies of the Software, and to permit persons to whom the Software is
- * furnished to do so, subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be included in all
- * copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-package ch.mazluc;
-
-import org.junit.jupiter.api.Test;
-
-import static org.junit.jupiter.api.Assertions.*;
-
-class BCMLDocumentTest {
-
-    @Test
-    void lineCount() {
-        BCMLDocument<Integer> document = new BCMLDocument<>();
-        assertEquals(0, document.lineCount());
-        document.append(new Line<>(3,"First line"));
-        assertEquals(1, document.lineCount());
-    }
-
-    @Test
-    void isEmpty() {
-        BCMLDocument<Integer> document = new BCMLDocument<>();
-        assertTrue(document.isEmpty());
-        document.append(new Line<>(3,"First line"));
-        assertFalse(document.isEmpty());
-    }
-
-    @Test
-    void getLine() {
-    }
-
-    @Test
-    void append() {
-    }
-
-    @Test
-    void clear() {
-    }
-
-    @Test
-    void serialize() {
-    }
-
-    @Test
-    void iterator() {
-    }
-}
\ No newline at end of file
